	.ENABLE	LC
	.GLOBL	RNDSAV,III,SAVJMP,BUFOUT
;
	;-----------------------------------------------------
	;    ПРОГРАММА ПРЕОБРАЗОВАНИЯ ЧИСЕЛ
	;  ИЗ СИМВОЛЬНОГО ФОРМАТА В ФОРМАТ С ПЛАВАЮЩЕЙ ЗАПЯТОЙ
	;-----------------------------------------------------
	;
PACK::	MOV	@SP,R3
	CLR	@SP
	CLR	-(SP)
	CLR	-(SP)
	MOV	R3,-(SP)
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	R4,-(SP)
	MOV	R5,-(SP)
	MOV	#-18.,-(SP)
	MOV	#101,-(SP)
	MOV	32(SP),R5
	ADD	R5,30(SP)
	CLR	R0
	CLR	R1
	CLR	R2
	CLR	R3
1$:	CMP	R5,30(SP)
	BGE	17$
	MOVB	(R5)+,R4
;	CMPB	R4,#40
;	BEQ	1$
;
	CMPB	R4,#'+
	BEQ	7$
	CMPB	R4,#'-
	BNE	4$
	INC	26(SP)
	BR	7$
;
3$:	MOVB	(R5)+,R4
;	CMPB	R4,#40
;	BEQ	7$
4$:	SUB	#60,R4
	BLT	15$
	BNE	5$
	CMP	2(SP),#-18.
	BNE	5$
	TSTB	23(SP)
	BEQ	7$
	DEC	24(SP)
	BR	7$
5$:	CMPB	R4,#11
	BGT	18$
	INC	2(SP)
	BGT	7$
	CALL	PDAUG5
	CALL	PDAUG2
	ADD	R4,R3
	ADC	R2
	ADC	R2
	ADC	R0
7$:	CMP	R5,30(SP)
	BLT	3$
	BR	6$
;
32$:	TSTB	27(SP)
	BEQ	24$
	NEG	R3
24$:	ADD	R3,24(SP)
	MOV	32(SP),R3
;
8$:	DEC	R5
6$:	MOV	R5,10(SP)
	TST	R0
	BNE	9$
	TST	R1
	BNE	9$
	TST	R2
	BNE	9$
	TST	R3
	BEQ	17$
9$:	TSTB	23(SP)
	BEQ	2$
	NEG	2(SP)
2$:	TST	2(SP)
	BGE	11$
	CLR	2(SP)
11$:	ADD	24(SP),2(SP)
	BGT	12$
	BLT	25$
	JMP	30$
;
12$:	CMP	R0,#31462
	BHI	14$
	CALL	PDAUG5
	INC	(SP)
13$:	DEC	2(SP)
	BGT	12$
	JMP	30$
;
14$:	CALL	PD5DL4
	ADD	#3,(SP)
	BR	13$
;
15$:	CMPB	R4,#-2
	BNE	8$
	TSTB	23(SP)
	BNE	8$
	COMB	23(SP)
	MOV	2(SP),24(SP)
	BR	7$
;
16$:	CLR	R0
	CLR	R1
	CLR	R2
	CLR	R3
17$:	JMP	31$
;
18$:	BICB	#40,R4
	SUB	#24,R4
	BEQ	19$
	DEC	R4
	BNE	8$
19$:	CMPB	(R5),#100	;ELSE OR NAME?
	BGT	8$
	BICB	#40,-(R5)
	MOVB	(R5)+,22(SP)
10$:	MOVB	(R5)+,R4
	CMP	R5,30(SP)
	BHI	8$
;	CMPB	R4,#40
;	BEQ	10$
	MOV	R3,32(SP)
	CLR	R3
	CMPB	R4,#'+
	BEQ	20$
	CMPB	R4,#'-
	BNE	22$
	INCB	27(SP)
20$:	MOVB	(R5)+,R4
	CMP	R5,30(SP)
	BHI	32$
22$:;	CMPB	R4,#40
;	BEQ	20$
	SUB	#60,R4
	BLT	32$
	CMPB	R4,#11
	BGT	32$
	CMP	R3,#500
	BHIS	20$
	ASL	R3
	ADD	R3,R4
	ASL	R3
	ASL	R3
	ADD	R4,R3
	BR	20$
;
34$:	TRAP	6
;
25$:	TST	R0
	BLT	27$
26$:	DEC	(SP)
	CALL	PDAUG2
	BPL	26$
27$:	CALL	DG4DL5
	SUB	#3,(SP)
	INC	2(SP)
	BLT	25$
;
30$:	DEC	(SP)
	CALL	PDAUG2
	BCC	30$
	ADD	#200,(SP)
	BLE	16$
	CMP	(SP),#377
	BGT	34$
	CLRB	R3
	BISB	R2,R3
	SWAB	R3
	CLRB	R2
	BISB	R1,R2
	SWAB	R2
	CLRB	R1
	BISB	R0,R1
	SWAB	R1
	CLRB	R0
	BISB	(SP),R0
	SWAB	R0
	ROR	26(SP)
	CALL	PDAL2
	ADC	R3
	ADC	R2
	ADC	R1
	ADC	R0
	BVS	34$
	BCS	34$
31$:	MOV	R0,24(SP)
	MOV	R1,26(SP)
	MOV	R2,30(SP)
	MOV	R3,32(SP)
	CMP	(SP)+,(SP)+
	MOV	(SP)+,R5
	MOV	(SP)+,R4
	MOV	(SP)+,R3
	MOV	(SP)+,R2
	MOV	(SP)+,R1
	MOV	(SP)+,R0
	RETURN
;
	;---------------------------------------------------------
	;	ПОДПРОГРАММА РАСПАКОВКИ ЧИСЕЛ
	;	ИЗ ФОРМАТА С ПЛАВАЮЩЕЙ ЗАПЯТОЙ (ОДИН. ИЛИ ДВОЙНОЙ)
	;	В СИМВОЛЬНЫЕ ФОРМАТЫ G,F,E,D
	;---------------------------------------------------------
;
EGO::	MOV	(SP)+,R5
	MOV	(SP)+,R0
	MOV	@SP,R1
	CLR	R2
	CLR	R3
	MOV	#6,@SP
	MOV	#42403,-(SP)
	BR	GO
;
DGO::	MOV	(SP)+,R5
	MOV	(SP)+,R0
	MOV	(SP)+,R1
	MOV	(SP)+,R2
	MOV	@SP,R3
	MOV	#20,(SP)
	MOV	#42003,-(SP)
GO:	MOV	#1,-(SP)
	MOV	#BUFOUT,-(SP)
	MOV	#30,-(SP)
	MOV	R5,-(SP)
;
UNPCK::	MOV	R4,-(SP)
	MOV	R4,SAVJMP
	CMP	-(SP),-(SP)
	CLR	-(SP)
	CLR	-(SP)
	ADD	16(SP),14(SP)
;
	ROL	R0
	ROL	6(SP)
	SWAB	R0
	MOVB	R0,2(SP)
	BNE	2$
	CLR	R4
	BR	3$
;
2$:	SEC
	ROR	R0
	CLRB	R0
	SWAB	R1
	BISB	R1,R0
	CLRB	R1
	SWAB	R2
	BISB	R2,R1
	CLRB	R2
	SWAB	R3
	BISB	R3,R2
	CLRB	R3
;
	SUB	#200,2(SP)
	BLT	20$
	BEQ	30$
;
10$:	TST	R0
	BLT	11$
	CALL	PDAUG2
	DEC	2(SP)
	BGT	10$
	BR	30$
11$:	CALL	DG4DL5
	INC	(SP)
	SUB	#3,2(SP)
	BGT	10$
	BEQ	30$
;
20$:	CMP	R0,#146314
	BHIS	21$
	CMP	2(SP),#-3
	BGT	21$
	CALL	DG5DL4
	DEC	(SP)
	ADD	#2,2(SP)
	BR	22$
21$:	CALL	PDAL2
22$:	INC	2(SP)
	BNE	20$
;
30$:	CLR	R4
31$:	CALL	DG5DL4
	CALL	UDAUG8
	TST	R4
	BNE	3$
	DEC	(SP)
	BR	31$
;
3$:	MOV	24(SP),R5
	ADD	20(SP),R5
	TSTB	22(SP)
	BEQ	4$
	MOV	R5,2(SP)
	CALL	ROUND1
	RORB	22(SP)
	BCC	5$
	CMP	@SP,#-1
	BLT	5$
	MOV	2(SP),R5
	CMP	@SP,R5
	BGT	5$
	SUB	@SP,R5
	CLRB	22(SP)
	MOV	R5,24(SP)
	CLR	20(SP)
	BR	41$
;
4$:	ADD	(SP),R5
41$:	DEC	14(SP)
44$:	MOV	14(SP),R5
	SUB	24(SP),R5
	DEC	R5
	MOV	R5,4(SP)
	DEC	R5
	TSTB	22(SP)
	BNE	40$
	ADD	(SP),20(SP)
	BLE	40$
	SUB	20(SP),R5
	CALL	SIGN
	BR	42$
;
40$:	CALL	SIGN
	MOVB	#'.,(R5)+
	MOVB	#'0,(R5)+
;
42$:	MOV	4(SP),R5
	TST	20(SP)
	BGT	43$
	INC	R5
43$:	SUB	20(SP),R5
	CALL	NUMB
	TSTB	22(SP)
	BEQ	UNPEND
	BR	50$
;
5$:	SUB	#5,14(SP)
	TST	20(SP)
	BLE	44$
	MOV	14(SP),R5
	SUB	24(SP),R5
	DEC	R5
	MOV	R5,4(SP)
	SUB	20(SP),R5
	DEC	R5
	CALL	SIGN
	CALL	NUMB
50$:	SUB	20(SP),(SP)
	MOVB	23(SP),(R5)+
	MOV	(SP),R4
	BGE	52$
	NEG	R4
	MOVB	#'-,(R5)+
	BR	53$
;
52$:	MOVB	#'+,(R5)+
53$:	MOVB	#'0,(R5)
54$:	SUB	#12,R4
	BLT	55$
	INCB	@R5
	BR	54$
;
55$:	ADD	#72,R4
	INC	R5
	MOVB	R4,(R5)+
UNPEND:	MOVB	#40,(R5)+
	SUB	24(SP),R5
	ADD	#10,SP
	MOV	(SP)+,R4
	CLR	SAVJMP
	MOV	(SP)+,4(SP)
	CMP	(SP)+,(SP)+
	ROL	2(SP)
	MOV	R5,2(SP)
	RETURN
;
DG5DL4:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	CALL	UDAL2
	CALL	UDAL2
	ADC	R3
	ADC	R2
	ADC	R1
	ADC	R0
	ADD	(SP)+,R3
	ADC	R2
	ADC	R1
	ADC	R0
	ADC	R4
	ADD	(SP)+,R2
	ADC	R1
	ADC	R0
	ADC	R4
	ADD	(SP)+,R1
	ADC	R0
	ADC	R4
	ADD	(SP)+,R0
	ADC	R4
	RETURN
;
DG4DL5:	MOV	#20,R4
	CALL	UDAL2
	MOV	R3,-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)
	MOV	R0,-(SP)
1$:	CALL	UDAL2
	CALL	UDAL2
2$:	CALL	UDAL2
	ADD	6(SP),R3
	ADC	R2
	ADC	R1
	ADC	R0
	ADD	4(SP),R2
	ADC	R1
	ADC	R0
	ADD	2(SP),R1
	ADC	R0
	ADD	@SP,R0
	NEG	R4
	BLT	2$
	DEC	R4
	BGT	1$
	ADD	#10,SP
	RETURN
;
UDAUG8:	MOV	R5,-(SP)
	MOV	#3,R5
1$:	CALL	PDAUG2
	ROL	R4
	DEC	R5
	BGT	1$
	MOV	(SP)+,R5
	RETURN
;
ASTER:	TST	(SP)+
	MOV	16(SP),R5
	MOV	R5,24(SP)
	MOVB	#'%,(R5)+
	COM	22(SP)
	BR	UNPEND
;
ROUND1:	CMP	R5,#24
	BGT	4$
	TST	R5
	BEQ	5$
	BLT	4$
	MOV	R4,-(SP)
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	MOV	#100000,R0
	CLR	R1
	CLR	R2
	CLR	R3
1$:	DEC	R5
	BEQ	2$
	CALL	DG4DL5
	CALL	UDAL2
	CALL	UDAL2
	CALL	UDAL2
	BR	1$
2$:	CLR	R4
	ADD	(SP)+,R3
	ADC	R2
	ADC	R1
	ADC	R0
	ADD	(SP)+,R2
	ADC	R1
	ADC	R0
	ADD	(SP)+,R1
	ADC	R0
	ADD	(SP)+,R0
	ADC	R4
	ADD	(SP)+,R4
3$:	CMP	#12,R4
	BGT	4$
	INC	2(SP)
4$:	RETURN
;
5$:	ADD	#5,R4
	BR	3$
;
SIGN:	MOV	R5,26(SP)
	CMP	R5,20(SP)
	BLO	2$
	ROR	10(SP)
	BCC	1$
	MOVB	#'-,(R5)+
	RETURN
1$:	MOVB	#40,(R5)+
	RETURN
;
2$:	ROR	10(SP)
	BCS	ASTER
	INC	R5
	CMP	R5,20(SP)
	BLO	ASTER
	RETURN
;
NUMB:	CMP	#12,R4
	BGT	1$
	MOVB	#'1,(R5)+
	SUB	#12,R4
1$:	CMP	6(SP),R5
	BNE	2$
	MOVB	#'.,(R5)+
2$:	CMP	16(SP),R5
	BLOS	3$
	ADD	#60,R4
	MOVB	R4,(R5)+
	CLR	R4
	CALL	DG5DL4
	CALL	UDAUG8
	BR	1$
3$:	CMPB	-(R5),#'0
	BEQ	3$
	CMPB	@R5,#'.
	BNE	4$
	CMPB	-1(R5),#'0
	BHIS	5$
	MOVB	#'0,@R5
4$:	INC	R5
5$:	RETURN
;
UDAL2:	CLC
PDAL2:	ROR	R0
	ROR	R1
	ROR	R2
	ROR	R3
	RETURN
;
PD5DL4:	CMP	R0,#146314
	BCS	1$
	CLC
	CALL	PDAL2
	INC	2(SP)
1$:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	CLC
	CALL	PDAL2
	CLC
	CALL	PDAL2
	BR	PLIUS
;
PDAUG5:	MOV	R0,-(SP)
	MOV	R1,-(SP)
	MOV	R2,-(SP)
	MOV	R3,-(SP)
	CALL	PDAUG2
	CALL	PDAUG2
;
PLIUS:	ADD	(SP)+,R3
	ADC	R2
	ADC	R1
	ADC	R0
	ADD	(SP)+,R2
	ADC	R1
	ADC	R0
	ADD	(SP)+,R1
	ADC	R0
	ADD	(SP)+,R0
	RETURN
;
PDAUG2:	ASL	R3
	ROL	R2
	ROL	R1
	ROL	R0
	RETURN
;
STAND::	TST	(SP)+
	JMP	@(R4)+
;
IABS::	TST	@SP
	BPL	I1
INEG::	NEG	@SP
I1:	JMP	@(R4)+
;
ABS::	BIC	#100000,@SP
	JMP	@(R4)+
;
ISGN::	MOV	#1,R0
	TST	@SP
	BEQ	2$
	BPL	1$
	NEG	R0
1$:	MOV	R0,@SP
2$:	JMP	@(R4)+
;
DSGN::	CLR	4(SP)
	CLR	6(SP)
;
SSGN::	TST	@SP
	BEQ	1$
	ASL	@SP
	MOV	#100400,@SP
	ROR	@SP
	CLR	2(SP)
1$:	JMP	@(R4)+
;
ID::	MOV	@SP,R0
	CLR	@SP
	CLR	-(SP)
	MOV	R0,-(SP)
;
IS::	CLR	-(SP)
	MOV	2(SP),R1
	BGT	IR1
	BEQ	IR4
	NEG	R1
 IR1:	ROL	-(SP)
	MOV	#220,R2
	CLRB	4(SP)
 IR2:	ROL	R1
	BCS	IR3
	DEC	R2
	BR	IR2
 ;
 IR3:	MOVB	R1,5(SP)
	CLRB	R1
	BISB	R2,R1
	SWAB	R1
	ROR	(SP)+
	ROR	R1
	RORB	3(SP)
	MOV	R1,@SP
IR4:	JMP	@(R4)+
;
SD::	MOV	(SP)+,R1
	MOV	(SP)+,R2
	CLR	-(SP)
	CLR	-(SP)
	MOV	R2,-(SP)
	MOV	R1,-(SP)
	JMP	@(R4)+
;
DI::	MOV	(SP)+,2(SP)
	MOV	(SP)+,2(SP)
 ;
SI::	CLR	R2
	INC	R2
	MOV	(SP)+,R1
	ROL	@SP
	ROL	R1
	ROL	-(SP)
	MOVB	R1,R0
	CLRB	R1
	SWAB	R1
	SUB	#201,R1
	BLT	RI1
	BEQ	RI2
	CMP	#17,R1
	BLT	RI3
	SWAB	R0
	CLRB	R0
	BISB	3(SP),R0
 RI4:	ROL	R0
	ROL	R2
	DEC	R1
	BGT	RI4
 RI2:	NEG	R2
	BVS	RI5
	BGT	RI3
 RI7:	ROR	(SP)+
	BCS	RI6
	NEG	R2
 RI6:	MOV	R2,@SP
	JMP	@(R4)+
 ;
 RI5:	ROR	(SP)+
	BCS	RI6
 RI3:	TRAP	6
 RI1:	CLR	R2
	BR	RI7
;
PI::	MOV	#64302,-(SP)
	MOV	#121041,-(SP)
	MOV	#7732,-(SP)
	MOV	#40511,-(SP)
	JMP	@(R4)+
;
;		MACRO	DEFINITIONS
	.MACRO	PUSH,A
	.IRP	X,<A>
		MOV	X,-(SP)
	.ENDM
	.ENDM
;
	.MACRO	POP,A
	.IRP	X,<A>
		MOV	(SP)+,X
	.ENDM
	.ENDM
;
	.MACRO	FPUSH,A
	.NTYPE	ATV,A
	.IF	EQ,ATV&60-40
		MOV	A,-(SP)
		MOV	A,-(SP)
		MOV	A,-(SP)
		MOV	A,-(SP)
	.IFF
	.IF	EQ	ATV&7-6
	.REPT 4
	MOV	6+A,-(SP)
	.ENDR
	.IFF
		MOV	6+A,-(SP)
		MOV	4+A,-(SP)
		MOV	2+A,-(SP)
		MOV	A,-(SP)
	.ENDC
	.ENDC
	.ENDM
;
	.MACRO	FPOP,A
	.REPT	4
		MOV	(SP)+,A
	.ENDR
	.ENDM
;
.SBTTL	SUPPORT ENTRY $B5,	SIMULATE DOUBLE PRECISION REAL SUBTRACTION
.SBTTL	SUPPORT ENTRY $B7,	SIMULATE DOUBLE PRECISION REAL ADDITION
ROUND=1
;
; THESE ROUTINES PERFORM SOFTWARE SIMULATION OF DOUBLE PRECISION
; ADDITION AND SUBTRACTION OF THE FORM A (+-) B.  WHEN EVERYTHING
; IS SET UP (AT ABOUT 20$) THE STACK LOOKS LIKE THE FOLLOWING:
; (LOW MEMORY TO HIGH)
;
; SP==> POINTER TO MANTISSA NOT IN R1-R4
;	RESULT EXPONENT
;	RESULT SIGN
;	B SIGN
;	A SIGN
;	R0
;	R1
;	R2
;	R3	(REGISTERS SAVED AT CALL)
;	R4
;	R5
;	RETURN TO CALLER
;	B1
;	B2
;	B3	(B MANTISSA)
;	B4
;	A1
;	A2
;	A3	(A MANTISSA)
;	A4
;
; ALL REGISTERS ARE PRESERVED.  DURING EXECUTION, THE MANTISSA THAT
; NEEDS ALIGNMENT (BY SHIFTING RIGHT) IS HELD IN R1 (MSB) THRU R4 (LSB).
;
; WHEN FADD OR FSUB IS CALLED, THE ARGUMENTS HAVE ALREADY BEEN PLACED
; ON THE STACK AND THE STACK POINTER POINTS TO THE RETURN ADDRESS IN
; THE ABOVE STACK DESCRIPTION.
;
;
; FLOATING SUBTRACTION
;
$B5::
$DSUB$::			; SIMULATE REAL SUBTRACTION
	TST	-(SP)
	TST	2(SP)		; ZERO?
	BEQ	$B7		; YES, SO IT CAN'T BE NEGATED
	ADD	#100000,2(SP)	; NEGATE SIGN OF B ON STACK
	BR	$B7		; FALL THROUGH AND DO AN ADDITION (A-B=A+(-B))
;
; FLOATING ADDITION
;
$DADD$::TST	-(SP)
$B7::				; SIMULATE REAL ADDITION
	MOV	R5,-(SP)
	MOV	R4,-(SP)
	TST	SAVJMP
	BNE	1$
	MOV	R4,SAVJMP
	CLR	@SP
1$:	PUSH	<R3,R2,R1,R0>
;
; FIND SIGN AND EXPONENT FOR A
;
	CLR	-(SP)		; MAKE ROOM FOR SIGN
	MOV	SP,R4		; COPY STACK POINTER
	ADD	#30,R4		; POINT TO A1
	MOV	(R4),R0		; GET SIGN, EXPONENT, MSB OF MANTISSA
	BEQ	35$		; A IS ZERO SO ANSWER IS B
	ASL	R0		; SIGN INTO CARRY, EXPONENT IN UPPER BYTE
	ROR	(SP)		; RECORD SIGN (IN CARRY)
	CLRB	R0		; CLEAR MANTISSA BITS
	SWAB	R0		; EXPONENT IN LOW ORDER BYTE
	BISB	#200,(R4)	; SET HIDDEN BIT IS MSB OF MANTISSA
	CLRB	1(R4)		; CLEAR SIGN AND EXPONENT
;
; FIND SIGN AND EXPONENT FOR B
;
	CLR	-(SP)		; MAKE ROOM FOR SIGN
	MOV	SP,R5		; COPY STACK POINTER
	ADD	#22,R5		; POINT TO B1
	MOV	(R5),R1		; GET SIGN, EXPONENT, MSB OF MANTISSA
	BEQ	RETA1		; B IS ZERO SO ANSWER IS A
	ASL	R1		; SIGN INTO CARRY, EXPONENT IN UPPER BYTE
	ROR	(SP)		; RECORD SIGN
	CLRB	R1		; CLEAR MANTISSA BITS
	SWAB	R1		; EXPONENT IN LOW ORDER BYTE
	BISB	#200,(R5)	; SET HIDDEN BIT IN MSB OF MANTISSA
	CLRB	1(R5)		; CLEAR SIGN AND EXPONENT
;
; DETERMINE WHICH MANTISSA NEEDS TO BE SHIFTED RIGHT TO ALIGN DECIMAL POINTS
;
	MOV	R0,R2		; COPY A'S EXPONENT
	SUB	R1,R0		; R0=AEXP-BEXP
	BPL	10$		; SHIFT B RIGHT
	NEG	R0		; MAKE EXPONENT DIFFERENCE POSITIVE
	CMP	#56.,R0		; ARE EXPONENTS TOO DIFFERENT?
	BLT	RETB2		; YES, SO JUST RETURN B
	MOV	(SP),-(SP)	; RESULT SIGN=SIGN OF B
	MOV	R1,-(SP)	; RESULT EXPONENT=EXPONENT OF B
	ADD	#6,R5		; POINT TO END OF B (B4)
	MOV	R5,-(SP)	; SAVE POINTER
	MOV	R4,R5		; POINT TO A1
	BR	20$		; ALIGN A
35$:
	BR	RETB1		; IT'S TOO FAR TO REACH
;
; SHIFT B RIGHT
;
10$:
	CMP	#56.,R0		; EXPONENTS TOO DIFFERENT?
	BLT	RETA2		; YES, SO RETURN A
	MOV	2(SP),-(SP)	; RESULT SIGN=SIGN OF A
	MOV	R2,-(SP)	; RESULT EXPONENT=EXPONENT OF A
	ADD	#6,R4		; POINT TO END OF A (A4)
	MOV	R4,-(SP)	; SAVE POINTER TO OTHER MANTISSA
;
; R5 NOW POINTS TO MANTISSA TO SHIFT, SO THE MANTISSA BEING SHIFTED
; RIGHT IS PICKED UP AND PLACED INTO R1-R4.  IN ORDER TO OBTAIN TWO
; "GUARD" BITS, THE OTHER MANTISSA IS SHIFTED LEFT AT MOST THRICE.
; THERE IS PLENTY OF ROOM IN THE BYTE OCCUPIED BY THE EXPONENT, AND
; THE NORMALIZE ROUTINE WILL SHIFT THE RESULT RIGHT IF NECESSARY.
;
20$:
	TST	R0		; ANY SHIFTING NECESSARY
	BEQ	25$		; NOPE
	MOV	#3,R1		; SHIFT A MAX OF 3 TIMES
	CMP	R1,R0		; LESS THAT 3 REQUIRED?
	BLE	22$		; NOPE
	MOV	R0,R1		; YES, SO USE EXACT COUNT
22$:
	MOV	(SP),R4		; POINT TO LARGER NUMBER
	ASL	(R4)		; SHIFT LEFT
	ROL	-(R4)
	ROL	-(R4)
	ROL	-(R4)
	DEC	2(SP)		; DECREMENT RESULT EXPONENT
	DEC	R0		; COUNT SHIFT FOR LATER TOO
	DEC	R1		; COUNT THE SHIFT
	BGT	22$		; AND LOOP
25$:
	MOV	(R5)+,R1	; PICK UP MSB
	MOV	(R5)+,R2
	MOV	(R5)+,R3
	MOV	(R5)+,R4	; LSB
.IF	NDF	TINYFP
;
; TEST IF SHIFTING MANTISSA MORE THAN 8 BITS.  IF SO, USE FAST BYTE
; SHIFT OPERATIONS.
;
30$:
	CMP	#8.,R0		; SHIFTING 8 OR MORE PLACES?
	BGT	40$		; NOPE
	CLRB	R4		; CLEAR BYTE 6
	BISB	R3,R4		; BYTE 4 TO BYTE 6
	SWAB	R4		; 4/7
	CLRB	R3		; CLEAR BYTE 4
	BISB	R2,R3		; BYTE 2 TO BYTE 4
	SWAB	R3		; 2/5
	CLRB	R2		; CLEAR BYTE 2
	BISB	R1,R2		; BYTE 0 TO BYTE 2
	SWAB	R2		; 3/2
	CLRB	R1		; CLEAR BYTE 0
	SWAB	R1		; ZERO/1
	SUB	#8.,R0		; COUNT 8 PLACES SHIFTED
	BR	30$		; AND LOOP
.ENDC
;
; IF LESS THAN 8 SHIFTS LEFT, DO BIT SHIFTS
;
40$:
	TST	R0		; ANYTHING LEFT TO DO?
	BEQ	50$		; NOPE, OPERANDS ARE ALIGNED
45$:
	CLC			; SHIFT IN A ZERO
	ROR	R1		; MSB
	ROR	R2
	ROR	R3
	ROR	R4		; LSB
	DEC	R0		; COUNT THE SHIFT
	BGT	45$		; AND CONTINUE
;
; DETERMINE HOW TO DO ADDITION.  IF SIGNS OF A AND B ARE THE SAME THEN
; DO ADDITION.  IF SIGNS DIFFER THEN DO SUBTRACTION AND POSSIBLY FIX
; UP THE SIGN (A-B=-(B-A)).
;
50$:
	MOV	(SP)+,R5	; POINT TO LARGER MANTISSA
	CMP	4(SP),6(SP)	; COMPARE SIGNS OF B AND A
	BNE	70$		; ITS SOME KIND OF SUBTRACTION
;
; SIGNS ARE THE SAME SO WE CAN DO AN ADDITION ((-A)+(-B)=-(A+B))
;
	ADD	(R5),R4		; ADD LSB'S
	ADC	R3		; RIPPLE CARRY
	ADC	R2
	ADC	R1
	ADD	-(R5),R3	; THIRD WORDS
	ADC	R2
	ADC	R1
	ADD	-(R5),R2	; SECOND WORDS
	ADC	R1
	ADD	-(R5),R1	; MSB (NO POSSIBLE CARRY)
	BR	100$		; GET EXPONENT AND NORMAIZE RESULT
;
; OPERAND SIGNS DIFFER, SO DO A SUBTRACTION
;
70$:
	COM	2(SP)		; FIX UP RESULT'S SIGN
	SUB	(R5),R4		; SUBTRACT LSB'S
	SBC	R3		; RIPPLE BORROW
	SBC	R2
	SBC	R1
	SUB	-(R5),R3	; THIRD WORD
	SBC	R2
	SBC	R1
	SUB	-(R5),R2	; SECOND WORD
	SBC	R1
	SUB	-(R5),R1	; MSB (DON'T CARE ABOUT BORROW)
	BPL	100$		; RESULT IS POSITIVE!!
	COM	R1		; DO 4 WORD NEGATE
	COM	R2		; REMEMBER THE CIA
	COM	R3		; INSTRUCTION ON 8'S?
	COM	R4
	ADD	#1,R4		; ADD ONE TO LSB (WHY NOT INC R4?)
	ADC	R3		; RIPPLE CARRY
	ADC	R2
	ADC	R1
	COM	2(SP)		; SET CORRECT RESULT SIGN
100$:
	BR	$FNORM		; NORMALIZE RESULT AND EXIT

;
; RETURN A AS THE RESULT BECAUSE B IS ZERO (OR SUFFICIENTLY CLOSE)
;
RETA2:
	MOV	R2,R0		; GET EXPONENT OF A
RETA1:
	MOV	(R4),R3		; GET MANTISSA
	TST	(SP)+		; KILL B SIGN ON STACK
	SWAB	R0		; MOVE EXPONENT TO UPPER HALF
	ASLB	R3		; KILL HIDDEN BIT IN MANTISSA
	BIS	R0,R3		; SET EXPONENT IN WITH MANTISSA
	ASL	(SP)+		; PICK UP SIGN IN CARRY
	ROR	R3		; CREATE FINAL RESULT
	MOV	R3,(R4)		; STORE ORIGINAL WORD IN A1
	MOV	14(SP),24(SP)	; MOVE RETURN ADDRESS INTO PLACE
	BR	$RETAB		; AND FALL THROUGH
;
; RETURN B AS THE RESULT BECAUSE A IS ZERO OR THERE ABOUTS
;
RETB2:
	MOV	(R5),R3		; GET MANTISSA
	SWAB	R1		; MOVE EXPONENT TO UPPER HALF
	ASLB	R3		; KILL HIDDEN BIT
	BIS	R1,R3		; ADD EXPONENT TO MANTISSA
	ASL	(SP)+		; PICK UP SIGN IN CARRY
	ROR	R3		; GENERATE FINAL RESULT
	MOV	R3,(R5)		; AND STORE BACK ORIGINAL WORD
RETB1:
	TST	(SP)+		; KILL A SIGN ON STACK
	MOV	R4,R5		; POINT PAST B4 (A1)
	ADD	#10,R5		; POINT PAST A4
	MOV	-(R4),-(R5)	; COPY B4 TO A4
	MOV	-(R4),-(R5)	; COPY B3 TO A3
	MOV	-(R4),-(R5)	; COPY B2 TO A2
	MOV	-(R4),-(R5)	; COPY B1 TO A1
	MOV	-(R4),-(R5)	; COPY RETURN ADDRESS TO B4
;
; POP REGISTERS FROM STACK AND RETURN WITH RESULT ON THE STACK
;
$RETAB::
	POP	<R0,R1,R2,R3>
	MOV	(SP)+,R4
	BNE	1$
	MOV	SAVJMP,R4
	CLR	SAVJMP
1$:	MOV	(SP)+,R5
	ADD	#12,SP		; POINT TO MOVED RETURN ADDRESS (B4)
	JMP	@(R4)+		; RETURN TO CALLER

.SBTTL	$FNORM	FLOATING NORMALIZE
;
; THIS ROUTINE NORMALIZES THE FLOATING POINT MANTISSA IN R1-R4.
; THE STATE OF THE STACK IS SIMILAR TO THAT DESCRIBED ABOVE FOR
; FLOATING ADDITION, EXCEPT THAT THE RESULT EXPONENT IS ON TOP
; OF THE STACK.
;
$FNORM::
	MOV	(SP)+,R0	; GET RESULT EXPONENT
2$:
	CLC			; PREVENT ROUNDING PROBLEMS
1$:
	BIT	#177400,R1	; RIGHT SHIFT REQUIRED?
	BEQ	5$		; NOPE
	CLC			; SHIFT IN A ZERO
	ROR	R1		; MSB
	ROR	R2
	ROR	R3
	ROR	R4		; LSB (LOW BIT FALLS INTO BIT BUCKET)
	INC	R0		; COUNT THE SHIFT
	BR	1$		; CONTINUE MAX 8 TIMES
5$:
.IF	DF	ROUND		; ROUNDING?
	BCC	8$		; NO ROUNDING
	ADC	R4		; ADD IN ROUNDING BIT
	ADC	R3		; RIPPLE CARRY
	ADC	R2
	ADC	R1		; MAY REQUIRE ONE MORE SHIFT
	BR	1$		; SO CHECK AGAIN
8$:
.ENDC
	TSTB	R1		; IS NUMBER NORMALIZED?
	BMI	FNORM1		; YES!
	BNE	20$		; NOPE, BUT SOME BITS ARE SET LOW BYTE
	MOV	R1,-(SP)	; CHECK IF RESULT IS ZERO
	BIS	R2,(SP)
	BIS	R3,(SP)		; BY OR'ING TOGETHER
	BIS	R4,(SP)+	; ALL THE WORDS
	BNE	10$		; NOPE
	CLR	R0		; YES, SO EXPONENT IS ZERO
	CLR	(SP)		; AS IS THE SIGN
	BR	FNORM1		; TAKE FAST EXIT
;
; NO BITS SET IN FIRST 8 BITS OF MSB OF MANTISSA, SO PERFORM
; FAST LEFT BITE-SIZED SHIFT.
;
10$:
.IF	NDF	TINYFP
	SWAB	R2		; REVERSE BYTES 2/3
	BISB	R2,R1		; BYTE 3 TO BYTE 0
	CLRB	R2		; MAKE ROOM FOR NEXT BYTE
	SWAB	R3		; REVERSE BYTE 4/5
	BISB	R3,R2		; BYTE 5 TO BYTE 2
	CLRB	R3		; MAKE ROOM FOR NEXT BYTE
	SWAB	R4		; REVERSE BYTES 6/7
	BISB	R4,R3		; BYTE 7 TO BYTE 4
	CLRB	R4		; ZEROS INTO BYTE 6 (LSB)
	SUB	#8.,R0		; COUNT 8 SHIFTS
	BR	2$		; AND KEEP SHIFTING
.ENDC
20$:
	DEC	R0		; COUNT ONE SHIFT
	ASL	R4		; SHIFT LEFT LSB
	ROL	R3		; SHIFT 4 WORDS
	ROL	R2
	ROLB	R1		; SHIFT LEFT MSB
	BPL	20$		; NOT YET NORMALIZED
;
; MANTISSA IS NORMALIZED. ADD SIGN AND EXPONENT AND CHECK FOR
; OVERFLOW/UNDERFLOW.  THIS ENTRY POINT IS ALSO A FAST EXIT
; FROM THE ADD/SUBTRACT ROUTINE.
;
FNORM1::
	SWAB	R0		; PUT EXPONENT IN UPPER BYTE
	TSTB	R0		; ANY GARBAGE LEFT FROM EXPONENT?
	BNE	FLTERR		; YES!?! OVERFLOW/UNDERFLOW
FNORM2:
	ASLB	R1		; KILL HIDDEN BIT
	BIS	R0,R1		; ADD EXPONENT TO UPPER BYTE
	ASL	(SP)+		; GET SIGN OF RESULT IN CARRY
	ROR	R1		; AND PRESTO!  WE HAVE FLOATING RESULT
;
; STORE RESULT INTO STACK ON TOP OF A AND EXIT TO RETA2 WHICH CLEARS
; STACK, RESTORES REGISTERS, AND LEAVES THE RESULT ON THE STACK.
;
	MOV	SP,R5		; COPY STACK POINTER
	ADD	#32,R5		; POINT TO RESULT SLOT (A1)
	MOV	R1,(R5)+	; COPY SIGN, EXPONENT, MSB
	MOV	R2,(R5)+
	MOV	R3,(R5)+
	MOV	R4,(R5)+	; LSB
	ADD	#4,SP		; KILL SIGNS ON STACK
	MOV	14(SP),24(SP)	; COPY RETURN ADDRESS
	BR	$RETAB		; AND EXIT
FLTERR:
	TRAP	6
$FLZER::
	CLR	R0		; UNDERFLOW MAKES NUMBER ZERO
	CLR	R1
	CLR	R2
	CLR	R3
	CLR	R4
	CLR	(SP)		; POSITIVE ZERO!
	BR	FNORM2
;
.SBTTL	SUPPORT ENTRY $B3,	SIMULATE DOUBLE PRECISION REAL MULTIPLY
.GLOBL	$FNORM,	$FLZER
;
; THIS ROUTINE SIMULATES A DOUBLE PRECISION FLOATING POINT MULTIPLY.
; THE TWO OPERANDS ARE ON THE STACK WHEN THIS ROUTINE IS CALLED. THE
; STATE OF THE STACK (AT ABOUT 10$) IS AS FOLLOWS:
;
; SP==> RESULT EXPONENT
;	RESULT SIGN
;	UNUSED (REQUIRED FOR NORMALIZE)
;	UNUSED (REQUIRED FOR NORMALIZE)
;	R0
;	R1
;	R2
;	R3	(REGISTERS SAVE AT CALL)
;	R4
;	R5
;	RETURN TO CALLER
;	B1
;	B2
;	B3	(B MANTISSA)
;	B4
;	A1
;	A2
;	A3
;	A4
;
; ALL REGISTERS ARE PRESERVED.  DURING CALCULATIONS, THE RESULT IS BUILT
; IN R1-R4.  R0 POINTS TO THE MULTIPLIER (OR MULTIPLICAND, I CAN NEVER
; REMEMBER WHICH IS WHICH) WHICH IS ARRANGED TO BE THE MANTISSA WITH
; THE FEWEST NUMBER OF SIGNIFICANT BITS.  R5 POINTS TO THE OTHER OPERAND
; WHICH GETS SHIFTED RIGHT AS THE MULTIPLICATION IS PERFORMED.
;
; SPECIAL CASE HANDLING OF MULTIPLY BY ZERO
;
$ZERO::
	CLR	-(SP)		; RESULT SIGN
	JMP	$FLZER		; RESULT IS ZERO
;
; ENTRY POINT FOR MULTIPLY
;
$B3::				; SIMULATE DOUBLE REAL MULTIPLICATION
$DMUL$::
	TST	-(SP)
	MOV	R5,-(SP)
	MOV	R4,-(SP)
	TST	SAVJMP
	BNE	1$
	MOV	R4,SAVJMP
	CLR	@SP
1$:	PUSH	<R3,R2,R1,R0>
	SUB	#4,SP		; SKIP TWO WORDS (USED BY ADD/SUB)
	MOV	#200,R3		; USEFUL CONSTANT
.PAGE
;
; GET SIGN AND EXPONENT OF A
;
	CLR	R2		; HOLDS RESULT SIGN
	MOV	SP,R4		; COPY STACK POINTER
	ADD	#32,R4		; POINT TO A MSB
	MOV	(R4),R0		; PICK UP SIGN, EXPONENT, MSB OF MANTISSA
	BEQ	$ZERO		; ZERO TIMES ANYTHING IS ZERO!
	ASL	R0		; SHIFT SIGN INTO CARRY, BYTE ALIGN EXPONENT
	ADC	R2		; SIGN TO LOW ORDER BIT
	CLRB	R0		; CLEAR MSB OF MANTISSA
	SWAB	R0		; MOVE EXPONENT TO LOW BYTE
	BISB	R3,(R4)		; SET HIDDEN BIT IN MANTISSA
	CLRB	1(R4)		; CLEAR SIGN/EXPONENT
;
; GET SIGN AND EXPONENT OF B
;
	MOV	SP,R5		; COPY STACK POINTER
	ADD	#22,R5		; POINT TO MANTISSA OF B
	MOV	(R5),R1		; GET SIGN, EXPONENT AND MSB OF MANTISSA
	BEQ	$ZERO		; RESULT IS ZERO!
	ASL	R1		; SIGN INTO CARRY, BYTE ALIGN EXPONENT
	ADC	R2		; XOR OF SIGNS IN LOW BIT
	ROR	R2		; LOW BIT INTO CARRY
	ROR	R2		; AND BACK INTO SIGN BIT
	MOV	R2,-(SP)	; PUT RESULT SIGN ON STACK
	CLRB	R1		; CLEAR MANTISSA PART
	SWAB	R1		; EXPONENT TO LOW BYTE
	BISB	R3,(R5)		; SET HIDDEN BIT
	CLRB	1(R5)		; CLEAR SIGN AND EXPONENT
;
; CALCULATE RESULT EXPONENT
;
	ADD	R1,R0		; RESULT EXPONENT IS SUM OF OPERAND EXPONENTS
	SUB	R3,R0		; (AEXP+200)+(BEXP+200)-200=(AEXP+BEXP)+200
	MOV	R0,-(SP)	; SAVE RESULT EXPONENT (OVERFLOW CHECKED LATER)
.PAGE
.IF	NDF	TINYFP
;
; DETERMINE WHICH OPERAND HAS THE FEWEST NUMBER OF SIGNIFICANT BITS
;
	CLR	R0		; COUNT FOR A
	MOV	R4,R2		; COPY POINTER TO A'S MANTISSA
	ADD	#10,R2		; POINT PAST END OF A
10$:
	INC	R0		; COUNT A WORD
	TST	-(R2)		; ANY BITS SET?
	BEQ	10$		; NO, SO COUNT ANOTHER WORD
	CLR	R1		; COUNT FOR B
	MOV	R5,R3		; POINT TO B
	ADD	#10,R3		; POINT PAST END OF B
20$:
	INC	R1		; COUNT A WORD
	TST	-(R3)		; ANY BITS SET?
	BEQ	20$		; NO, SO COUNT ONE MORE WORD
	CMP	R0,R1		; WHICH HAS FEWER BITS
	BGE	30$		; A DOES
	MOV	R5,R0		; B DOES, SO USE B FOR LEFT SHIFTING
	MOV	R4,R5		; USE A FOR RIGHT SHIFTING
	BR	40$		; AND START CALCULATING
.IFF
	MOV	#56.,4(SP)	; SHIFT COUNT FOR TINY MULTIPLY
.ENDC
30$:
	MOV	R4,R0		; COPY POINTER TO A
40$:
	MOV	#3,R1		; GET COUNT (3 GUARD BITS)
45$:
	ADD	#6,R5		; POINT TO END OF MULTIPLIER
	CLC			; SHIFT IN A ZERO
	ROL	(R5)		; ROTATE LEFT
	ROL	-(R5)		; TO INCREASE
	ROL	-(R5)		; ACCURACY IN CASE WE
	ROL	-(R5)		; ROUND DURING NORMALIZATION
	DEC	(SP)		; ADJUST EXPONENT
	DEC	R1		; COUNT THIS SHIFT
	BGT	45$		; KEEP SHIFTING TO INTRODUCE GUARD BITS
;
; CLEAR RESULT (R1-R4)
;
	CLR	R1		; RESULT IS BUILT IN
	CLR	R2		; THESE REGISTERS
	CLR	R3
	CLR	R4		; LSB
.PAGE
;
; MAIN MULTIPLY LOOP.  AS THE MANTISSA POINTED TO BY R0 IS SHIFTED
; RIGHT, TESTS ARE MADE FOR POSSIBLE BYTE OR WORD SHIFTS.  SINCE
; WE PICKED THE SHORTER MANTISSA TO SHIFT RIGHT, THIS OPTIMIZATION
; MINIMIZES ITERATIONS THROUGH THIS LOOP.
;
50$:
.IF	NDF	TINYFP
	TSTB	6(R0)		; LAST BYTE ZERO?
	BNE	110$		; NOPE, SO DO SLOW MULTIPLY
	TSTB	7(R0)		; NEXT TO LAST BYTE ALSO ZERO?
	BNE	100$		; NOPE, DO BYTE SHIFT
	TST	4(R0)		; THIRD WORD ZERO?
	BNE	70$		; NO, SO DO WORD SHIFT
	TST	2(R0)		; SECOND WORD ZERO?
	BNE	60$		; NOPE, SO DO DOUBLE WORD SHIFT
	TST	(R0)		; FIRST WORD ZERO?
	BEQ	130$		; YES! ALL DONE!
;
; DO A THREE WORD RIGHT SHIFT OF MULTIPLIER AND RESULT
;
	MOV	(R0),6(R0)	; FIRST WORD TO LAST WORD
	CLR	(R0)		; ZEROS SHIFTED INTO FIRST WORD
	MOV	R1,R4		; FIRST WORD TO LAST WORD
	CLR	R1		; ZERO SHIFTED INTO
	CLR	R2		; FIRST THREE
	CLR	R3		; WORDS
	BR	50$		; CONTINUE
;
; DO A TWO WORD RIGHT SHIFT
;
60$:
	MOV	2(R0),6(R0)	; SECOND WORD TO LAST WORD
	MOV	(R0),4(R0)	; FIRST WORD TO THIRD WORD
	CLR	2(R0)		; ZEROES SHIFTED INTO FIRST
	CLR	(R0)		; TWO WORDS
	MOV	R2,R4		; SECOND WORD TO LAST WORD
	MOV	R1,R3		; FIRST WORD TO THIRD WORD
	CLR	R1		; ZEROES SHIFTED INTO FIRST
	CLR	R2		; TWO WORDS
	BR	50$		; CONTINUE
;
; SHIFT RIGHT ONE WORD
;
70$:
	MOV	4(R0),6(R0)	; THIRD WORD TO LAST WORD
	MOV	2(R0),4(R0)	; SECOND WORD TO THIRD WORD
	MOV	(R0),2(R0)	; FIRST WORD TO SECOND WORD
	CLR	(R0)		; ZEROES SHIFTED INTO FIRST WORD
	MOV	R3,R4		; THIRD WORD TO LAST WORD
	MOV	R2,R3		; SECOND WORD TO THIRD WORD
	MOV	R1,R2		; FIRST WORD TO SECOND WORD
	CLR	R1		; ZEROES SHIFTED INTO FIRST WORD
	BR	50$		; CONTINUE
.PAGE
;
; SHIFT RIGHT ONE BYTE.  IT LOOKS UGLY, BUT IT'S MUCH FASTER THAN
; BIT SHIFTING!
;
100$:
	MOVB	4(R0),6(R0)	; BYTE 4 TO BYTE 6
	SWAB	6(R0)		; 4/7 IN LAST WORD
	MOVB	2(R0),4(R0)	; BYTE 2 TO BYTE 4
	SWAB	4(R0)		; 2/5 IN THIRD WORD
	MOVB	(R0),2(R0)	; BYTE 0 TO BYTE 2
	SWAB	2(R0)		; 0/3 IN SECOND WORD
	CLRB	(R0)		; ZEROES SHIFTED INTO LOW BYTE
	SWAB	(R0)		; X/1 IN FIRST WORD
	CLRB	R4		; CLEAR BYTE 6
	BISB	R3,R4		; BYTE 4 TO BYTE 6
	SWAB	R4		; 4/7 IN LAST WORD
	CLRB	R3		; CLEAR BYTE 4
	BISB	R2,R3		; BYTE 2 TO BYTE 4
	SWAB	R3		; 2/5 IN THIRD WORD
	CLRB	R2		; CLEAR BYTE 2
	BISB	R1,R2		; BYTE 0 TO BYTE 2
	SWAB	R2		; 0/3 IN SECOND WORD
	CLRB	R1		; ZEROES SHIFTED INTO LOW BYTE
	SWAB	R1		; X/1 IN FIRST WORD
.IFF
	CLC			; NEEDED BECAUSE NO TSTB 6(R0) WAS DONE
.ENDC
;
; LAST BYTE CONTAINS INTERESTING BITS.  ROTATE MULTIPLICAND RIGHT AND
; CHECK IF ADDITION SHOULD BE DONE ON THIS PASS.
;
110$:
	ROR	(R0)+		; CARRY CLEARED BY TSTB AT 50$!
	ROR	(R0)+		; MULTIPLE WORD SHIFT
	ROR	(R0)+
	ROR	(R0)		; LSB
	BCC	120$		; ADDITION NOT NEEDED ON THIS PASS
	ADD	#6,R5		; POINT TO LSB OF MULTIPLIER
	ADD	(R5),R4		; LSB
	ADC	R3		; RIPPLE CARRY
	ADC	R2
	ADC	R1
	ADD	-(R5),R3	; THIRD WORD
	ADC	R2
	ADC	R1
	ADD	-(R5),R2	; SECOND WORD
	ADC	R1
	ADD	-(R5),R1	; FIRST WORD (MSB) NO CARRY!
;
; SHIFT RESULT RIGHT ONE BIT
;
120$:
	SUB	#6,R0		; POINT BACK TO START OF MULTIPLICAND
	CLC			; ZERO SHIFTED INTO MSB OF RESULT
	ROR	R1		; MULTIPLE WORD SHIFT
	ROR	R2
	ROR	R3
	ROR	R4		; LSB FALLS INTO BIT BUCKET
.IF	NDF	TINYFP
	BR	50$		; CONTINUE
.IFF
	DEC	4(SP)		; COUNT THIS LOOP
	BGT	50$		; MORE TO DO
.ENDC
;
; DONE MULTIPLYING.  PICK UP EXPONENT AND JUMP TO THE
; NORMALIZE ROUTINE WHICH CLEANS UP THE STACK AND RETURNS
; TO THE CALLER.
;
130$:
	JMP	$FNORM		; NORMALIZE RESULT IN R1-R4
.SBTTL	SUPPORT ENTRY $B1,	SIMULATE DOUBLE PRECISION REAL DIVISION
.GLOBL	$FNORM,	$RETAB,	$ZERO
;
; SIMULATES DOUBLE PRECISION FLOATING POINT DIVISION.  THE
; TWO OPERANDS ARE ON THE STACK WHEN THIS ROUTINE IS CALLED. THE
; DIVISION PERFORMED IS A/B.  THE STATE OF THE STACK AT ABOUT 10$
; IS AS FOLLOWS:
;
; SP==> RESULT EXPONENT
;	RESULT SIGN
;	SHIFT COUNT
;	UNUSED	(REQUIRED FOR NORMALIZE)
;	R0
;	R1
;	R2
;	R3	(REGISTERS SAVED AT CALL)
;	R4
;	R5
;	RETURN TO CALLER
;	B1
;	B2
;	B3	(B MANTISSA)
;	B4
;	A1
;	A2
;	A3	(A MANTISSA)
;	A4
;
; ALL REGISTERS ARE PRESERVED.  DURING CALCULATIONS, R1-R4 HOLD THE
; CURRENT REMAINDER OF THE DIVISION.  THE QUOTIENT IS BUILT BIT BY
; BIT AT THE LOCATION POINTED TO BY R0.  THIS ALGORITHM USES A NON-
; RESTORING NORMAILZED DIVISION METHOD DESCRIBED IN THE FP11-B
; HARDWARE MANUAL.  R5 POINTS TO THE MANTISSA OF THE DIVISOR.
;
;
; ENTRY POINT FOR DIVISION
;
$B1::				; SIMULATE REAL DIVISION
$DDIV$::			; SAVE ALL REGISTERS
	TST	-(SP)
	MOV	R5,-(SP)
	MOV	R4,-(SP)
	TST	SAVJMP
	BNE	1$
	MOV	R4,SAVJMP
	CLR	@SP
1$:	PUSH	<R3,R2,R1,R0>
	CLR	-(SP)		; UNUSED
	MOV	#58.,-(SP)	; SHIFT COUNT (WITH 2 GUARD BITS)
	MOV	#200,R3		; USEFUL CONSTANT
;
; PICK UP SIGN AND EXPONENT OF B (THE DIVISOR)
;
	CLR	R2		; USED TO BUILD RESULT SIGN
	MOV	SP,R5		; COPY STACK POINTER
	ADD	#22,R5		; POINT TO MSB OF B
	MOV	(R5),R4		; GET SIGN, EXPONENT, MSB
	BEQ	ZERDIV		; DIVISION BY ZERO!?!
	ASL	R4		; SIGN INTO CARRY, ALIGN EXPONENT
	ADC	R2		; SIGN IN LSB OF R2
	CLRB	R4		; ZAP MANTISSA BITS
	SWAB	R4		; EXPONENT TO LOWER BYTE
	NEG	R4		; REXP=(AEXP+200)-(BEXP+200)
	ADD	R3,R4		;     +200=(AEXP-BEXP)+200
	DEC	R4		; MINUS ONE FOR GUARD BITS
	BISB	R3,(R5)		; SET HIDDEN BIT
	CLRB	1(R5)		; KILL SIGN AND EXPONENT
;
; PICK UP SIGN AND EXPONENT OF A (THE DIVIDEND)
;
	MOV	SP,R0		; COPY STACK POINTER
	ADD	#32,R0		; POINT TO A MANTISSA
	MOV	(R0),R1		; GET SIGN, EXPONENT, MSB
	BEQ	ZER1		; RESULT IS ZERO
	ASL	R1		; ALIGN EXPONENT
	ADC	R2		; RESULT SIGN IN LSB
	ROR	R2		; RESULT SIGN TO CARRY
	ROR	R2		; RESULT SIGN IN SIGN BIT
	MOV	R2,-(SP)	; STORE RESULT SIGN
	CLRB	R1		; ZAP MANTISSA BITS
	SWAB	R1		; EXPONENT TO LOWER BYTE
	ADD	R1,R4		; CALCULATE RESULT EXPONENT
	MOV	R4,-(SP)	; STORE RESULT EXPONENT
	BISB	R3,(R0)		; SET HIDDEN BIT
	CLRB	1(R0)		; KILL SIGN AND EXPONENT
;
; PICK UP DIVIDEND IN R1-R4 AND AT THE SAME TIME ZERO
; THE SLOT WHERE THE RESULT IS BUILT
;
	MOV	(R0),R1		; MSB
	CLR	(R0)+
	MOV	(R0),R2		; SECOND WORD
	CLR	(R0)+
	MOV	(R0),R3		; THIRD WORD
	CLR	(R0)+
	MOV	(R0),R4		; LAST WORD
	CLR	(R0)		; R0 POINTS TO LAST WORD OF RESULT
	BR	20$
.PAGE
;
; MAIN DIVISION LOOP.  IF REMAINDER IS POSITIVE THEN DIVISOR IS SUBTRACTED
; BUT IF REMAINDER IS NEGATIVE THEN DIVISOR IS ADDED TO CORRECT FOR THE
; PROBLEM IN THE PREVIOUS LOOP.  AFTER THE ARITHMETIC OPERATION, THE
; REMAINDER IS NORMALIZED IF NECESSARY, AND THE LOOP CONTINUES.
;
10$:
	ADD	#6,R5		; POINT TO LSB OF DIVISOR
	ADD	(R5),R4		; MULTIPLE WORD ADD
	ADC	R3		; RIPPLE CARRY
	ADC	R2
	ADC	R1
	ADD	-(R5),R3	; THIRD WORD
	ADC	R2
	ADC	R1
	ADD	-(R5),R2	; SECOND WORD
	ADC	R1
	ADD	-(R5),R1	; FIRST WORD (NO CARRY!)
	BR	30$		; SHIFT LEFT AND GET RESULT BIT
;
; SUBTRACT DIVISOR FROM REMAINDER
;
20$:
	ADD	#6,R5		; POINT TO LSB OF DIVISOR
	SUB	(R5),R4		; MULTIPLE WORD SUBTRACTION
	SBC	R3		; RIPPLE BORROW
	SBC	R2
	SBC	R1
	SUB	-(R5),R3	; THIRD WORD
	SBC	R2
	SBC	R1
	SUB	-(R5),R2	; SECOND WORD
	SBC	R1
	SUB	-(R5),R1	; FIRST WORD (IGNORE BORROW)
;
; COMPLEMENT SIGN OF REMAINDER SO THAT IT SHIFTS LEFT INTO LSB
; OF RESULT.
;
30$:
	ADD	#100000,R1	; FLIP SIGN BIT
;
; SHIFT 8 WORDS LEFT.  MSB OF REMAINDER BECOMES LSB OF QUOTIENT
;
40$:
	ASL	R4		; ZERO INTO LSB OF REMAINDER
	ROL	R3		; THIRD REMAINDER WORD
	ROL	R2		; SECOND REMAINDER WORD
	ROL	R1		; SIGN BIT INTO CARRY
	ROL	(R0)		; SIGN BIT INTO LSB OF QUOTIENT
	ROL	-(R0)		; THIRD QUOTIENT WORD
	ROL	-(R0)		; SECOND QUOTIENT WORD
	ROL	-(R0)		; FIRST QUOTIENT WORD
	ADD	#6,R0		; POINT TO LAST QUOTIENT WORD
	DEC	4(SP)		; COUNT THIS SHIFT
	BEQ	60$		; DONE!
.PAGE
;
; NORMALIZE REMAINDER
;
	TST	R1		; REMAINDER POSITIVE?
	BMI	50$		; NEGATIVE, SPECIAL NORMALIZE
	TSTB	R1		; NORMALIZED?
	BMI	20$		; YES!
	BR	40$		; SHIFT LEFT TO NORMALIZE
50$:
	TSTB	R1		; NORMALIZED?
	BPL	10$		; YES
	BR	40$		; SHIFT LEFT TO NORMALIZE
;
; DONE WITH DIVISION.  PUT RESULT INTO R1-R4
; AND NORMAILZE RESULT.
;
60$:
	MOV	(R0),R4		; LSB OF RESULT
	MOV	-(R0),R3	; THIRD WORD
	MOV	-(R0),R2	; SECOND WORD
	MOV	-(R0),R1	; MSB
	JMP	$FNORM		; NORMALIZE RESULT
ZERDIV:
	TRAP	11.
ZER1:
	JMP	$ZERO		; RETURN ZERO AS A RESULT

;
; THIS ROUTINE CALCULATES THE DOUBLE PRECISION SQUARE ROOT OF THE
; ARGUMENT PASSED ON THE STACK.  THE ALGORITHM USED IS SQRT 0150
; FROM HART, "COMPUTER APPROXIMATIONS".
;
.GLOBL	$DMUL$,	$DADD$,	$DDIV$,STAND
$B91::
	MOV	R4,-(SP)
	MOV	R0,-(SP)	; SAVE R0
;
; FIRST, GET EXPONENT OF ARGUMENT
;
	MOV	4(SP),R0	; GET MSB OF ARGUMENT
	BMI	SQRERR		; SQUARE ROOT OF A NEGATIVE NUMBER!
SQRTR:
	BEQ	30$		; SQR(0) IS ZERO!
	MOV	R4,SAVJMP
	ASL	R0		; ALIGN EXPONENT
	CLRB	R0		; CLEAR MSB OF MANTISSA
	SWAB	R0		; EXPONENT TO LOW BYTE
	SUB	#200,R0		; CONVERT FROM EXCESS 200 TO BINARY
	MOV	R0,-(SP)	; SAVE BINARY EXPONENT
;
; REDUCE RANGE OF ARGUMENT (N) SO THAT 0.5 < N <= 1.0
;
	FPUSH	6(SP)		; COPY ARGUMENT
	BIC	#^C177,(SP)	; CLEAR EXPONENT (AND SIGN)
	BIS	#^F0.5,(SP)	; REDUCE RANGE
;
; GENERATE INITIAL APPROXIMATION TO SQUARE ROOT (GOOD TO 2 PLACES)
;
	FPUSH	SQRT0		; ADDITIVE CONSTANT
	FPUSH	10(SP)		; N
	FPUSH	SQRT1		; MULTIPLIER
	JSR	R4,STAND
	.WORD	$DMUL$		; X=N*0.59016206
	.WORD	$DADD$		; X=N*0.59016206+0.41730759
	.WORD	5$
;
; NOW DO THREE NEWTON ITERATIONS WHICH GIVE 18.125 PLACES OF
; ACCURACY.
;
5$:	MOV	#3,R0		; LOOP COUNT
10$:
	FPUSH	10(SP)		; PUSH N
	FPUSH	10(SP)		; PUSH X
	JSR	R4,STAND
	.WORD	$DDIV$		; N/X
	.WORD	$DADD$		; N/X+X
	.WORD	15$
15$:	SUB	#200,(SP)	; X=(N/X+X)/2
	DEC	R0		; COUNT THIS LOOP
	BGT	10$		; MORE TO DO
;
; CALCULATE FINAL ROOT FROM RANGE REDUCED ROOT
;
	MOV	20(SP),R0	; GET ORIGINAL EXPONENT
	ASR	R0		; DIVIDE BY 2
	BCC	20$		; IS WAS EVEN POWER OF TWO
	FPUSH	SQRT2		; SQR(2)
	JSR	R4,STAND
	.WORD	$DMUL$		; X=X*SQR(2)
	.WORD	20$
20$:
	SWAB	R0		; MOVE EXPONENT TO UPPER BYTE
	CLRB	R0		; KILL JUNK IN LOW BYTE
	ROR	R0		; SHIFT EXPONENT TO FIT
	ADD	R0,(SP)		; MULTIPLY BY POWER OF TWO
	BPL	25$		; RESULT IS POSITIVE
	ADD	#100000,(SP)	; CORRECT BORROW FROM EXPONENT
25$:
	FPOP	24(SP)		; PUT INTO RESULT SLOT
	ADD	#12,SP		; KILL JUNK ON STACK
30$:
	MOV	(SP)+,R0	; RESTORE R0
	MOV	(SP)+,R4
	CLR	SAVJMP
	JMP	@(R4)+

;
; CONSTANTS USED BY SQUARE ROOT ROUTINE
;
SQRT0:
	.FLT4	0.41730759
SQRT1:
	.FLT4	0.59016206
SQRT2:
	.FLT4	1.41421356237309504880 ; SQR(2)
SQRERR:
	TRAP	5
;
.SBTTL	SUPPORT ENTRY $B99,	'EXP(REAL)' (DOUBLE PRECISION)
;
; CALCULATES DOUBLE PRECISION POWER OF E.  THE RATIONAL APPROXIMATION
; REQUIRES A RANGE REDUCTION TO 0<=X<1/64.  THE RESULT IS GOOD TO ABOUT
; 18 PLACES.
;
; THE STATE OF THE STACK AT ABOUT 20$ IS:
;
; SP==>	X1
;	X2
;	X3	(RANGE REDUCED ARG)
;	X4
;	SCALE COUNT
;	POWER OF 2
;	SIGN FLAG
;	R5
;	R4
;	R3
;	R2
;	R1	(SAVED AT CALL)
;	R0
;	RETURN
;	N1
;	N2
;	N3	(ARGUMENT)
;	N4
;
.GLOBL	$DADD$,	$DMUL$,	$DDIV$,	$DSUB$,	$FRACT,STAND
$B99::				; DOUBLE PRECISION EXPONENTIAL
	TST	@SP
	BMI	1$
	CMP	@SP,#41660
	BLO	2$
	BHI	3$
	CMP	2(SP),#7463
	BLO	2$
3$:	CLR	SAVJMP
	TRAP	6
1$:	CMP	@SP,#141660
	BLOS	2$
	CLR	@SP
	CLR	2(SP)
	CLR	4(SP)
	CLR	6(SP)
	JMP	@(4)+
2$:	TST	-(SP)		; PRESERVE REGISTERS
	MOV	R5,-(SP)
	MOV	R4,-(SP)
	TST	SAVJMP
	BNE	7$
	MOV	R4,SAVJMP
	CLR	@SP
7$:	PUSH	<R3,R2,R1,R0>
	CLR	-(SP)		; SIGN FLAG
	CLR	-(SP)		; POWER OF 2 REDUCTION
	CLR	-(SP)		; SCALE COUNTER
;
; APPROXIMATION IS EXP(X)=2^(X/LN(2))
;
	FPUSH	24(SP)		; PUSH ARG
	FPUSH	LN2IN		; LN(2)
	JSR	R4,STAND	; X=X*1/LN(2)
	.WORD	$DMUL$
	.WORD	$EXP1
;
; DO RANGE REDUCTION TO GET 0<=X<1/64
;
$EXP1:
	MOV	(SP),R1	;	 GET SIGN/EXPONENT/MSB OF MANTISSA
	MOV	R1,14(SP)	; SET SIGN FLAG
	BIC	#100000,R1	;TAKE ABSOLUTE VALUE
	CMP	#36777,R1	; (1/64)*.99999....
	BGE	20$		; ARG IS IN RANGE!
	CMP	#40177,R1	; IS X<=1.0
	BGE	10$		; YES, DO FAST RANGE REDUCTION
	JSR	R4,STAND	; GET FRACTION PART, INTEGER PART TO R5
	.WORD	$FRACT
	.WORD	5$
5$:	MOV	R5,12(SP)	; SAVE INTEGER PART
	BIC	#100000,(SP)	; GET ABSOLUTE VALUE
	MOV	(SP),R1		; GET MSB OF FRACTION PART
10$:
	CMP	#36777,R1	; (1/64)*.99999.....
	BGE	20$		; X IS IN RANGE NOW
	SUB	#200,R1		; DIVIDE X BY 2
	INC	10(SP)		; COUNT DIVISION
	BR	10$		; KEEP REDUCING
20$:
	MOV	R1,(SP)		; SAVE MSB OF REDUCED ARG
	MOV	SP,R1		; COPY STACK POINTER
	ADD	#10,R1		; POINT PAST X
;
; Y=X*X
;
	FPUSH	-(R1)		; X
	FPUSH	-(R1)		; X
	JSR	R4,STAND
	.WORD	$DMUL$
	.WORD	21$
	.WORD	$DMUL$
	.WORD	22$
	.WORD	$DADD$
	.WORD	23$
	.WORD	$DMUL$
	.WORD	24$
	.WORD	$DADD$
	.WORD	25$
	.WORD	$DADD$
	.WORD	26$
	.WORD	$DSUB$
	.WORD	27$
	.WORD	$DDIV$
	.WORD	28$
;
; P=X*(P1*Y+P0)
;
21$:	MOV	#EXPTAB,R1	; POINT TO COEFFICIENT TABLE
	FPUSH	0(SP)		; Y
	FPUSH	-(R1)		; P1
	JMP	@(R4)+
22$:	FPUSH	-(R1)		; P0
	JMP	@(R4)+
23$:	FPUSH	20(SP)		; X
	JMP	@(R4)+
;
; Q=Y+Q0
;
24$:	FPUSH	10(SP)		; Y
	FPUSH	-(R1)		; Q0
	JMP	@(R4)+
25$:	FPUSH	0(SP)		; Q
	FPUSH	20(SP)		; P
	JMP	@(R4)+
26$:	FPUSH	10(SP)		; Q
	FPUSH	30(SP)		; P
	JMP	@(R4)+
;
; IF ARG < 0 THEN EXP=(Q-P)/(Q+P)
;
27$:	TST	64(SP)		; SIGN FLAG
	BPL	30$		; ARG WAS POSITIVE
	FPUSH	10(SP)		; Q+P
	JMP	@(R4)+
28$:	FPOP	6(SP)		; ADJUST STACK
	BR	40$
;
; IF ARG>0 THEN EXP=(Q+P)/(Q-P)
;
30$:
	JSR	R4,STAND	; (Q+P)/(Q-P)
	.WORD	$DDIV$
	.WORD	40$
40$:
	MOV	50(SP),R0	; GET SCALE FACTOR
	BEQ	60$		; NO SCALING NEEDED
;
; BECAUSE OF RANGE REDUCTION, EXP=EXP^(SCALE FACTOR)
;
50$:
	FPUSH	0(SP)
	JSR	R4,STAND	; SQUARE RESULT
	.WORD	$DMUL$
	.WORD	51$
51$:	DEC	R0		; COUNT IT
	BGT	50$		; MORE TO DO
;
; NOW MULTIPLY BY POWER OF 2
;
60$:
	MOV	52(SP),R0	; GET POWER
	SWAB	R0		; MOVE TO UPPER BYTE
	TSTB	R0		; TOO BIG?
	BEQ	70$		; NOPE
	CLRB	R0		; CLEAR -1 IN LOW BYTE
70$:
	ASR	R0		; SHIFT TO EXPONENT SLOT
	ADD	R0,(SP)		; MULTIPLY BY 2^POWER
	FPOP	72(SP)		; PUT RESULT IN RESULT SLOT
	ADD	#46,SP		; KILL JUNK ON STACK
				; POP REGS
	POP	<R0,R1,R2,R3>
	MOV	(SP)+,R4
	BNE	9$
	MOV	SAVJMP,R4
	CLR	SAVJMP
9$:	MOV	(SP)+,R5
	TST	(SP)+		; 
	JMP	@(R4)+
;
; CONSTANTS USED IN APPROXIMATION
;
LN2IN:
	.FLT4	1.44269504088896	; 1/LN(2)
OQ0:
	.FLT4	.208136948963436784218221E2
OP0:
	.FLT4	.72134769672177719062488E1
OP1:
	.FLT4	.577621944696111185E-1
EXPTAB:					; EXP COEFFICIENTS
;
.SBTTL	SUPPORT ENTRY $B103,	'LN(REAL)' (DOUBLE PRECISION)
;
; THIS ROUTINE CALCULATES THE DOUBLE PRECISION NATURAL LOG OF THE
; ARGUMENT PASSED ON THE STACK. AFTER A RANGE REDUCTION TO
; 1/SQR(2) <= X <= SQR(2), ALGORITHM LOGE 2705 FROM HART, "COMPUTER
; APPROXIMATIONS" IS USED TO CALCULATE LN(X) TO 18 PLACES.
;
; AT ABOUT 10$: THE STATE OF THE STACK IS:
;
; SP==>	POWER OF 2 OF ARG
;	R2
;	R1
;	R0
;	RETURN ADDRESS
;	N1
;	N2
;	N3	(ARGUMENT)
;	N4
;
.GLOBL	$DMUL$,	$DDIV$,	$DADD$,	$DSUB$,	$APPRX,STAND
BADLOG:
	TRAP	5
$B103::				; NATURAL LOG
	MOV	R4,-(SP)
	TST	SAVJMP
	BNE	1$
	MOV	R4,SAVJMP
	CLR	@SP
1$:	PUSH	<R0,R1,R2>	; SAVE SOME REGS
;
; PUT EXPONENT OF ARG ON STACK AND REDUCE RANGE TO 0.5 <= X < 1
;
	MOV	10(SP),R1	; GET SIGN/EXPONENT/MSB OF MANTISSA
	BEQ	BADLOG		; LOG OF ZERO!!!!!
	ASL	R1		; BYTE ALIGN EXPONENT
	BCS	BADLOG		; OOPS!  LOG OF NEGATIVE NUMBER
	SWAB	R1		; EXPONENT TO LOW BYTE
	CLR	R0		; TARGET OF EXPONENT
	BISB	R1,R0		; MOVE EXPONENT TO R0
	CLRB	R1		; ZAP EXPONENT
	BISB	#200,R1		; SET EXPONENT TO ZERO (EXCESS 200)
	SWAB	R1		; EXPONENT TO UPPER BYTE
	CLC			; ZERO TO SIGN
	ROR	R1		; MAKE INTO FLOATING POINT FORMAT
	SUB	#200,R0		; CONVERT EXPONENT FROM EXCESS 200
	MOV	R0,-(SP)	; SAVE BINARY EXPONENT
;
; REDUCE RANGE TO 1/SQR(2) <= X <= SQR(2)
;
	CMP	#40065,R1	; 1/SQR(2)  (APPROX)
	BLT	10$		; ARG IS IN RANGE
	ADD	#200,R1		; MULTIPLY ARG BY 2
	DEC	(SP)		; ADJUST BINARY EXPONENT
;
; BUILD PARAMETERS USED IN RATIONAL APPROXIMATION
;
10$:
	MOV	SP,R0		; POINT PAST WHERE X WILL BE PUSHED
	FPUSH	12(SP)		; PUSH ARG
	MOV	R1,(SP)		; CALCULATE X (REDUCED RANGE)
	FPUSH	-(R0)		; PUSH X, POINT PAST WHERE Z GOES
	CLR	-(SP)		; PUSH 1.0
	CLR	-(SP)
	CLR	-(SP)
	MOV	#^F1.0,-(SP)	; 1.0
	JSR	R4,STAND	; X-1
	.WORD	$DSUB$
	.WORD	12$
	.WORD	$DADD$
	.WORD	$DDIV$
	.WORD	14$
	.WORD	$APPRX
	.WORD	16$
12$:	FPUSH	10(SP)		; X
	CLR	-(SP)		; 1.0
	CLR	-(SP)
	CLR	-(SP)
	MOV	#^F1.0,-(SP)	; 1.0
	JMP	@(R4)+
;
; CALCUALTE Z*P(Z^2)/Q(Z^2)
;
14$:	MOV	#LOGTAB,R0	; POINT TO COEFFICIENTS
	JMP	@(R4)+
;
; IF RANGE REDUCTION THEN MULTIPLY RESULT BY N*LN(2) WHERE
; ARGUMENT=2^N*X
;
16$:	MOV	20(SP),R0	; GET POWER OF 2 OF ARG
	BEQ	50$		; NO RANGE REDUCTION HAPPENED
	MOV	R0,-(SP)		; RECORD SIGN
	BPL	20$		; POWER IS POSITIVE
	NEG	R0		; GET ABSOLUTE VALUE
;
; CONVERT POWER OF 2 TO FLOATING POINT NUMBER
;
20$:
	MOV	#8.,R1		; ASSUMED EXPONENT
30$:
	ASLB	R0		; NORMALIZED?
	BCS	40$		; YES
	DEC	R1		; NOPE, ADJUST EXPONENT
	BR	30$		; AND CONTINUE NORMALIZATION
.PAGE
;
; MULTIPLY POWER OF 2 BY LN(2)
;
40$:
	ADD	#200,R1		; CONVERT TO EXCESS 200 NOTATION
	SWAB	R1		; EXPONENT TO UPPER BYTE
	BIS	R1,R0		; SET EXPONENT
	ASL	(SP)+		; PICK UP SIGN IN CARRY
	ROR	R0		; CONVERT TO FLOATING POINT FORMAT
	CLR	-(SP)		; PUSH NUMBER ON STACK
	CLR	-(SP)
	CLR	-(SP)
	MOV	R0,-(SP)	; POWER OF 2
	FPUSH	LN2		; LN(2)
	JSR	R4,STAND
	.WORD	$DMUL$		; N*LN(2)
	.WORD	$DADD$		; ADJUST FOR INITIAL RANGE REDUCTION
	.WORD	50$
;
; PUT ANSWER IN RESULT SLOT AND EXIT
;
50$:
	FPOP	30(SP)		; MOVE RESULT
	ADD	#12,SP		; WIPE OUT JUNK
LOGEX:				; RESTORE REGS
	POP	<R2,R1,R0>
	MOV	(SP)+,R4
	BNE	1$
	MOV	SAVJMP,R4
	CLR	SAVJMP
1$:	JMP	@(R4)+
;
; CONSTANTS USED IN THE APPROXIMATION
;
LN2:
	.FLT4	.6931471805599453094172321
IQ0:
	.FLT4	-.120069589779605254717525E2
IQ1:
	.FLT4	.19480966070088973051623E2
IQ2:
	.FLT4	-.89111090279378312337E1
IP0:
	.FLT4	-.240139179559210509868484E2
IP1:
	.FLT4	.30957292821537650062264E2
IP2:
	.FLT4	-.96376909336868659324E1
IP3:
	.FLT4	.4210873712179797145
LOGTAB:
	.BYTE	3,3		; TABLE OF LOG COEFFICIENTS
;
; DOUBLE PRECISION SINE AND COSINE APPROXIMATIONS.  THIS ROUTINE USES
; ALGORITHM NUMBER 3345 IN HART, "COMPUTER APPROXIMATIONS".  THE ARGUEMENT
; IS REDUCED TO 0 <= X <= PI/2, AND THEN A SIMPLE POLYNOMIAL IS USED
; TO APPROXIMATE THE DESIRED FUNCTION.
;
; THE STATE OF THE STACK AT ABOUT 10$: IS AS FOLLOWS:
;
; SP==> A1
;	A2
;	A3	( WORK AREA )
;	A4
;	R5
;	R4
;	R3
;	R2	( REGISTERS SAVED AT CALL )
;	R1
;	R0
;	QUADRANT/SIGN FLAG
;	RETURN ADDRESS
;	N1
;	N2
;	N3	( ARGUMENT/RESULT )
;	N4
;
.GLOBL	$DMUL$,	$DSUB$,	$APPRX,	$FRACT,STAND
$B95::					; DOUBLE PRECISION COSINE
	TST	-(SP)
	CLR	-(SP)			; CLEAR QUADRANT FLAG
	ASL	4(SP)			; SIGN OF ARGUMENT INTO CARRY
	BEQ	ONE			; COS(0.0)=1.0
	SEC				; COS(X)=SIN(PI/2 + X)
	BR	SINCOS			; FALL INTO COMMON CODE
ONE:
	MOV	#^F1.0,4(SP)		; FAST RETURN FOR COS(0)
	BR	SCEXI			; THAT WAS EASY!
$B93::					; DOUBLE PRECISION SINE
	TST	-(SP)
	CLR	-(SP)			; CLEAR QUADRANT/SIGN FLAG
	ASL	4(SP)			; SIGN OF ARGUMENT INTO CARRY
	BEQ	SCEXI			; SIN(0.0)=0.0
	ROL	(SP)			; SIGN FLAG TO LOW BIT OF QUADRANT FLAG
SINCOS:
	ROL	(SP)			; QUADRANT/SIGN NOW KNOWN. (ZERO INTO CARRY)
	ROR	4(SP)			; TAKE ABSOLUTE VALUE OF ARGUMENT
;
; SAVE ALL THE REGISTERS
;
	MOV	R5,-(SP)
	MOV	R4,-(SP)
	TST	SAVJMP
	BNE	1$
	MOV	R4,SAVJMP
	CLR	@SP
1$:	PUSH	<R3,R2,R1,R0>
;
; REDUCE RANGE TO FIRST QUADRANT
;
	FPUSH	20(SP)			; X
	FPUSH	TWODPI			; 2/PI
	JSR	R4,STAND		; X=X/(PI/2)
	.WORD	$DMUL$
	.WORD	$FRACT			; GET FRACTION PART, INTEGER PART IN R5
	.WORD	5$
	.WORD	$DSUB$
	.WORD	10$
5$:	ADD	R5,24(SP)		; ADD QUADRANT TO QUADRANT FLAG WORD
	ASR	24(SP)			; IS ANGLE IN AN ODD QUADRANT?
	BCC	10$			; NOPE
	CLR	-(SP)			; YES, SO X=X-1 (SUBTRACT PI/2 FROM ORIGINAL X)
	CLR	-(SP)
	CLR	-(SP)
	MOV	#^F1.0,-(SP)		; 1.0
	JMP	@(R4)+
10$:
	BIC	#100000,(SP)		; TAKE ABSOLUTE VALUE OF X
	BEQ	20$			; X=0.0
	CMP	#^F1E-13,(SP)		; IS ARGUMENT TOO SMALL?
	BLO	14$			; NUMBER IS REASONABLE
;
; SPECIAL CASE OF X VERY TINY.  LIM (X-->0) SIN(X)==X
;
	FPUSH	C0			; QUICK EVALUATION OF POLYNOMIAL
	JSR	R4,STAND		; AND EXIT
	.WORD	$DMUL$
	.WORD	20$
;
; EVALUATE POLYNOMIAL
;
14$:
	FPUSH	0(SP)			; COPY X
	MOV	#SCTAB,R0		; POINT TO COEFFICIENTS
	JSR	R4,STAND		; DO SIMPLE POLYNOMIAL APPROXIMATION P(X^2)
	.WORD	$APPRX
	.WORD	$DMUL$			; SIN=X*P(X^2)
	.WORD	20$
;
; CALCULATE SIGN OF RESULT
;
20$:
	ASL	(SP)			; SIGN TO CARRY
	BEQ	30$			; RESULT IS 0.0
	ADC	24(SP)			; PROPAGATE SIGN
	ASR	24(SP)			; SIGN FLAG TO CARRY
	ROR	(SP)			; SIGN TO RESULT
30$:
	FPOP	26(SP)			; POP RESULT INTO RESULT SLOT
;
; CLEAN UP STACK AND EXIT
;
	POP	<R0,R1,R2,R3>
	MOV	(SP)+,R4
	BNE	2$
	MOV	SAVJMP,R4
	CLR	SAVJMP
2$:	MOV	(SP)+,R5
SCEXI:
	CMP	(SP)+,(SP)+		; QUADRANT/SIGN FLAG
	JMP	@(R4)+
;
; COEFFICIENTS USED TO APPROXIMATE SIN/COS FUNCTIONS
;
C0:
	.FLT4	0.15707963267948966188272E1
	.FLT4	-0.64596409750624619108547
	.FLT4	 0.7969262624616543562977E-1
	.FLT4	-0.468175413530264260121E-2
	.FLT4	 0.1604411847068220716E-3
	.FLT4	-0.359884300720869272E-5
	.FLT4	 0.5692134872719023E-7
	.FLT4	-0.66843217206396E-9
	.FLT4	 0.587061098171E-11
SCTAB:
	.WORD	8.			; ORDER OF POLYNOMIAL
TWODPI:
	.FLT4	.63661977236758134307553505349	 ; 2/PI
;
; THIS ROUTINE PROVEDES THE DOUBLE PRECISION TANGENT OF THE
; ARGUMENT PASSED ON THE STACK.
;
$TAN::
	MOV	R4,-(SP)
	MOV	R4,SAVJMP
	FPUSH	2(SP)
	JSR	R4,STAND
	.WORD	$B93
	.WORD	1$
	.WORD	$B95
	.WORD	2$
	.WORD	$DDIV$
	.WORD	3$
1$:	FPUSH	12(SP)
4$:	JMP	@(R4)+
2$:	TST	@SP
	BNE	4$
	TRAP	5
3$:	FPOP	10(SP)
	MOV	(SP)+,R4
	CLR	SAVJMP
	JMP	@(R4)+
;
; THIS ROUTINE PROVEDES THE DOUBLE PRECISION INVERSE TANGENT OF
; THE ARGUMENT PASSED ON THE STACK.  THE ALGORITHM USED IS
; ARCTN 5076 FROM HART, "COMPUTER APPROXIMATIONS".
;
; THE STATE OF THE STACK AT ABOUT 10$: IS AS FOLLOWS:
;
; SP==>	SIGN FLAG
;	R3
;	R2
;	R1
;	R0
;	RETURN ADDRESS
;	N1
;	N2	(ARGUMENT)
;	N3
;	N4
.GLOBL	$DDIV$,	$DSUB$,	$DADD$,	$APPRX, STAND
$B97::				; DOUBLE PRECISION ARC-TANGENT
	MOV	R4,-(SP)
	TST	SAVJMP
	BNE	1$
	MOV	R4,SAVJMP
	CLR	@SP
1$:	PUSH	<R3,R2,R1,R0>
	CLR	-(SP)		; ASSUME POSITIVE ARG
	CLR	R1		; ASSUME NO RANGE REDUCTION
	FPUSH	14(SP)		; PUSH ARG
	MOV	(SP),R0		; GET SIGN/EXPONENT/MSB OF MANTISSA
	BPL	10$		; ARG IS POSITIVE
	COM	10(SP)		; SET NEGATIVE FLAG
	BIC	#100000,R0	; CLEAR FOR RANGE COMPARES
	MOV	R0,(SP)		; TAKE ABSOLUTE VALUE OF ARG
	MOV	R0,24(SP)	; TAKE ABSOLUTE VALUE OF ORIGINAL ARG
;
; CHECK IF RANGE REDUCTION NECESSARY
;
10$:
	CMP	#37724,R0	; TAN(PI/8) (APPROX)
	BGT	30$		; X<TAN(PI/8) SO NO RANGE REDUCTION
	CMP	#40432,R0	; TAN(3*PI/8) (APPROX)
	BLE	20$		; X>TAN(3*PI/8)
;
; TAN(PI/8) <= X < TAN(3*PI/8)  SO X=(X-1)/(X+1)
;
	CLR	-(SP)		; PUSH 1.0
	CLR	-(SP)
	CLR	-(SP)
	MOV	#^F1.0,-(SP)	; 1.0
	JSR	R4,STAND
	.WORD	$DSUB$
	.WORD	11$
	.WORD	$DADD$
	.WORD	$DDIV$
	.WORD	12$
11$:	FPUSH	24(SP)		; X
	CLR	-(SP)
	CLR	-(SP)
	CLR	-(SP)
	MOV	#^F1.0,-(SP)	; 1.0
	JMP	@(R4)+
12$:	MOV	#PIDV4,R1	; POINT TO PI/4
	BR	30$		; DO APPROXIMATION
;
; X >= TAN(3*PI/8) SO X=-1/X
;
20$:
	ADD	#10,SP		; WIPE OUT ARG ON STACK
	CLR	-(SP)		; PUSH -1.0
	CLR	-(SP)
	CLR	-(SP)
	MOV	#^F-1.0,-(SP)	; -1.0
	FPUSH	24(SP)		; X
	JSR	R4,STAND
	.WORD	$DDIV$
	.WORD	21$
21$:	MOV	#PIDV2,R1	; POINT TO PI/2
;
; APPROXIMATE ATN(X) WHERE X <= TAN(PI/8)
;
30$:
	MOV	#ATNTAB,R0	; POINT TO COEFFICIENT TABLE
	JSR	R4,STAND	; PERFORM RATIONAL APROXIMATION
	.WORD	$APPRX
	.WORD	31$
;
; FIX UP SIGN AND ANY RANGE REDUCTION
;
31$:	TST	R1		; RANGE REDUCTION?
	BEQ	40$		; NOPE
	FPUSH	0(R1)		; PUSH CORRECTION FACTOR
	JSR	R4,STAND
	.WORD	$DADD$
	.WORD	40$
40$:
	TST	10(SP)		; SIGN CORRECT?
	BPL	50$		; YES
	ADD	#100000,(SP)	; NOPE FLIP SIGN
50$:
	FPOP	22(SP)		; PUT ANSWER IN RESULT SLOT
	ADD	#2,SP		; KILL JUNK ON STACK
	POP	<R0,R1,R2,R3>	; POP REGS
	MOV	(SP)+,R4
	BNE	2$
	MOV	SAVJMP,R4
	CLR	SAVJMP
2$:	JMP	@(R4)+
;
; CONSTANTS USED IN APPROXIMATION
;
PIDV4:
	.FLT4	.78539816339744830961566	; PI/4
PIDV2:
	.FLT4	1.57079632679489661923132	; PI/2
Q0:
	.FLT4	.445413400592906804445595E2
Q1:
	.FLT4	.92324801072300974840693E2
Q2:
	.FLT4	.62835930511032376833267E2
Q3:
	.FLT4	.1550397755142198752523E2
P0:
	.FLT4	.445413400592906803197511E2
P1:
	.FLT4	.77477687719204208616481E2
P2:
	.FLT4	.40969264832102256374186E2
P3:
	.FLT4	.666057901700926265753E1
P4:
	.FLT4	.1589740288482307048
ATNTAB:
	.BYTE	4,4		; TABLE OF COEFFICIENTS
	.TITLE	$FRACT AND RND
;
; 	THIS ROUTINE RETURNS TNE RANDOM VALUE
;
;
RAN::
	MOV	R4,SAVJMP
	TST	@SP
	BEQ	1$		; PREVIOUS VALUE
	BPL	2$		; NEXT VALUE
	CLR	RNDSAV
	MOV	#PIDV2,R0
	MOV	#III,R5
	.REPT	4
	MOV	(0)+,(5)+
	.ENDR
2$:	MOV	#III,R5
	MOV	(5)+,R0
	MOV	(5)+,R1
	MOV	(5)+,R2
	MOV	(5)+,R3
	BEQ	22$
	ASL	R3
	ROL	R2
	ROL	R1
	ROL	R0
	SUB	#10,R5
	ADD	(5)+,R0
	ADD	(5)+,R1
	ADC	R0
	ADD	(5)+,R2
	ADC	R1
	ADD	@R5,R3
	ADC	R2
	ADD	(5)+,R0
	BPL	23$
	ADD	#100000,R0
23$:	MOV	R3,-(5)
	MOV	R2,-(5)
	MOV	R1,-(5)
	MOV	R0,-(5)
	MOV	#201,R5
24$:	ASL	R3
	ROL	R2
	ROL	R1
	ROL	R0
	BCS	25$
	DEC	R5
	BR	24$
22$:	MOV	#3,R3
	INC	R0
	BR	23$
25$:	CLRB	R3
	BISB	R2,R3
	SWAB	R3
	CLRB	R2
	BISB	R1,R2
	SWAB	R2
	CLRB	R1
	BISB	R0,R1
	SWAB	R1
	CLRB	R0
	BISB	R5,R0
	SWAB	R0
	ROR	R0
	ROR	R1
	ROR	R2
	ROR	R3
	TST	RNDSAV
	BEQ	9$
	MOV	SP,R5
	MOV	R0,(5)+
	MOV	R1,(5)+
	MOV	R2,(5)+
	MOV	R3,(5)+
8$:	MOV	SP,R0
	MOV	#RNDSAV,R5
	.REPT	4
	MOV	(0)+,(5)+
	.ENDR
1$:	MOV	RNDSAV,@SP
	MOV	RNDSAV+2,2(SP)
	MOV	RNDSAV+4,4(SP)
	MOV	RNDSAV+6,6(SP)
	CLR	SAVJMP
	JMP	@(4)+
9$:	PUSH	<R3,R2,R1,R0>
	MOV	R4,R0
	CLR	R1		; SIGNAL REGISTER
	FPUSH	10(SP)
	BIC	#100000,@SP
13$:	CMP	#40200,@SP
	BLT	10$
	BGT	11$
10$:	DEC	R1
	BGE	15$
	JSR	R4,STAND
	.WORD	12$
	.WORD	$DDIV$
	.WORD	13$
11$:	MOV	SP,R2
	.REPT	4
	MOV	(2)+,16(R2)
	.ENDR
	INC	R1
	BLE	15$
	JSR	R4,STAND
	.WORD	12$
	.WORD	$DMUL$
	.WORD	13$
12$:	CLR	-(SP)
	CLR	-(SP)
	CLR	-(SP)
	MOV	#41040,-(SP)
	JMP	@(4)+
15$:	ADD	#10,SP
	JSR	R4,STAND
	.WORD	12$
	.WORD	$DDIV$
	.WORD	16$
	.WORD	$DADD$
	.WORD	$DSUB$
	.WORD	17$
16$:	CLR	-(SP)
	CLR	-(SP)
	CLR	-(SP)
	MOV	#40200,-(SP)
	JMP	@(4)+
17$:	BIC	#100000,@SP
	MOV	SP,R1
	MOV	#III,R2
	.REPT	4
	MOV	(1)+,(2)+
	.ENDR
	MOV	R0,R4
	BR	8$
;
;
; THIS ROUTINE RETURNS THE FRACTIONAL PART OF THE ARGUMENT PASSED ON THE
; STACK.  THE LAST PART OF THE INTEGER IS RETURNED IN R5, AND THE FRACTIONAL
; PART OF THE ARG IS RETURNED ON THE STACK.  THIS ROUTINE IS CALLED BY
; THE TRIG FUNCTIONS AND THE EXP ROUTINE TO PERFORM RANGE REDUCTION.  NO
; REGISTERS ARE PRESERVED, AND ALL REGISTERS ARE DESTROYED.
;
$FRACT::			; RETURN FRACTION PART
	MOV	R4,-(SP)
	MOV	2(SP),R1	; PICK UP NUMBER
	MOV	4(SP),R2
	MOV	6(SP),R3
	MOV	10(SP),R4
;
; GET SIGN OF INTEGER PART AND SPLIT UP EXPONENT AND MANTISSA
;
	CLR	R5		; ASSUME NO INTEGER PART
	MOV	R1,R0		; COPY SIGN/EXPONENT/MSB OF MANTISSA
	MOV	R0,-(SP)	; REMEMBER THE SIGN
	ASL	R0		; BYTE ALIGN EXPONENT
	CLRB	R0		; WIPE OUT MANTISSA BITS
	SWAB	R0		; EXPONENT TO LOW BYTE
	BIC	#177400,R1	; CLEAR EXPONENT BITS
	BIS	#200,R1		; SET "HIDDEN" BIT
;
; DETERMINE IF NUMBER IS ALREADY A FRACTION OR IF INTEGER PART IS TOO
; BIG TO HAVE A FRACTIONAL PART.
;
	SUB	#200,R0		; CONVERT FROM EXCESS 200 TO BINARY
	BLE	60$		; NUMBER IS ALREADY FRACTION
	CMP	#56.,R0		; NUMBER TOO BIG?
	BGT	20$		; NO
;
; NUMBER IS TOO BIG, SO IT HAS NO FRACTIONAL PART.  RETURN
; ZERO AS THE FRACTION.
;
	MOV	#77770,R5	; SET BIG INTEGER
10$:
	CLR	4(SP)		; ZERO THE RESULT
	CLR	6(SP)
	CLR	10(SP)
	CLR	12(SP)
	BR	60$		; RETURN TO CALLER
;
; SHIFT NUMBER LEFT TO PUT INTEGER PART TO LEFT OF IMPLIED BINARY
; POINT WITH FRACTION PART TO THE RIGHT.  R5 IS USED TO HOLD
; OVERFLOW WHICH SHIFTS OUT OF R1.  THIS OVERFLOW IS EITHER NOT
; SIGNIFICANT (FOR QUADRANT DETERMINATION) OR AN ERROR (FOR EXP).
;
20$:
	ASL	R4		; SHIFT LEFT ONE PLACE
	ROL	R3
	ROL	R2
	ROL	R1
	ROL	R5		; OVERFLOW INTO R5
	ADC	R5		; RECORD MORE OVERFLOW
	DEC	R0		; COUNT SHIFT IN EXPONENT
	BGT	20$		; MORE SHIFTING TO DO
;
; SAVE LOWER BITS OF INTEGER PART IN R5 AND PREPARE TO NORMALIZE REMAINING
; FRACTION.
;
	SWAB	R5		; MAKE ROOM IN LOW BYTE
	SWAB	R1		; MOVE INTEGER TO LOW BYTE
	BISB	R1,R5		; MOVE INTEGER BITS
	TST	(SP)		; NEGATIVE NUMBER?
	BPL	30$		; NOPE
	NEG	R5		; YES, RECORD THIS FACT
30$:
	CLRB	R1		; KILL INTEGER BITS
	SWAB	R1		; MOVE MANTISSA TO LOW BYTE
;
; TEST IF FRACTION NEEDS TO BE NORMALIZED.  IF REMAINING BITS ARE ZERO,
; NO NORMALIZE IS NEEDED, OR THE NUMBER MIGHT ALREADY BE NORMALIZED
; (50% CHANCE)
;
	TSTB	R1		; NUMBER NORMALIZED?
	BMI	50$		; YES, TAKE FAST EXIT
	MOV	R1,-(SP)	; CHECK IF FRACTION IS ZERO
	BIS	R2,(SP)		; BY OR'ING TOGETHER
	BIS	R3,(SP)		; ALL THE BITS
	BIS	R4,(SP)+	; ANY BITS SET?
	BEQ	10$		; RESULT IS ZERO
;
; NORMALIZE FRACTION
;
40$:
	ASL	R4		; SHIFT NUMBER 1 PLACE LEFT
	ROL	R3
	ROL	R2
	ROL	R1
	DEC	R0		; COUNT SHIFT IN EXPONENT
	TSTB	R1		; NUMBER NORMALIZED YET?
	BPL	40$		; NOPE
;
; CONVERT BACK TO FLOATING POINT FORMAT
;
50$:
	ADD	#200,R0		; EXCESS 200 NOTATION FOR EXPONENT
	SWAB	R0		; MOVE EXPONENT TO UPPER BYTE
	ASLB	R1		; ALIGN MANTISSA, KILL HIDDEN BIT
	BIS	R0,R1		; FILL IN EXPONENT
	ROR	R1		; CHANGE TO FLOATING FORMAT
	MOV	R1,4(SP)	; STORE NUMBER IN RESULT SLOT
	MOV	R2,6(SP)
	MOV	R3,10(SP)
	MOV	R4,12(SP)
60$:
	TST	(SP)+		; POP SIGN ARG
	MOV	(SP)+,R4
	BIC	#100000,@SP	; FRACTION ALWAYS POSITIVE
	JMP	@(R4)+
;
; THIS ROUTINE RETURNS INTEGER PART OF THE ARGUMENT PASSED ON
; THE STACK.ALL REGISTERS ARE DESTROYED.
;
$FIX::
	MOV	R4,SAVJMP
	MOV	R4,-(SP)	; SAVE RETURN REGISTRE
	FPUSH	2(SP)		; PUSH ARGUMENT ON STACK
$FIX1:	FPUSH	0(SP)
	JSR	R4,STAND
	.WORD	$FRACT
	.WORD	1$
	.WORD	$DADD$
	.WORD	2$
1$:	TST	10(SP)
	BLE	3$
	BIS	#100000,@SP
3$:	JMP	@(R4)+
2$:	FPOP	10(SP)		; POP REZULT ON THE STACK
	MOV	(SP)+,R4
	CLR	SAVJMP
	BR	3$
;
; THIS ROUTINE RETURNS THE HIGHEST INTEGER VALUE LESS THEN
; ARGUMENT PASSED ON THE STACK.
;
$INT::
	TST	@SP
	BPL	$FIX
	MOV	R4,SAVJMP
	MOV	R4,-(SP)
	FPUSH	2(SP)
	FPUSH	0(SP)
	JSR	R4,STAND
	.WORD	$FRACT
	.WORD	1$
	.WORD	$DADD$
	.WORD	$FIX1
1$:	TST	@SP
	BEQ	2$
	ADD	#10,SP
	CLR	-(SP)
	CLR	-(SP)
	CLR	-(SP)
	MOV	#140200,-(SP)
	JMP	@(R4)+
2$:	ADD	#10,SP
	BR	$FIX1
; THIS ROUTINE IS CALLED BY THE TRANCENDENTAL FUNCTIONS TO EVALUATE
; A RATIONAL APPROXIMATION OF THE FORM X*P(X^2)/Q(X^2) WHERE X IS
; THE ARGUMENT PASSED ON THE STACK.  R0 POINTS PAST THE TABLE OF
; COEFFICIENTS TO USE IN THE APPROXIMATION.  R0 POINTS TO TWO BYTES
; OF INFORMATION. THE FIRST BYTE IS THE ORDER OF P AND THE SECOND BYTE
; IS THE ORDER OF Q.  DURING THE COMPUTATION, THE STATE OF THE STACK
; IS AS FOLLOWS:  (ITEMS IN PARENTHESES ARE QUAD WORD FLOATING POINT
; NUMBERS)
;
; SP==>	(Q)
;	(P)
;	(X^2)
;	(X)
;	R4
;	R3	REGISTERS SAVED AT CALL
;	R2
;	R1
;	UNUSED
;	(X)
;
;
; THE ALGORITHM USES HORNER'S METHOD TO EVALUATE THE POLYNOMIALS
;
.GLOBL	$DSUB$,	$DADD$,	$DMUL$,	$DDIV$,STAND

$APPRX::			; RATIONAL APPROXIMATION
	TST	-(SP)
	PUSH	<R1,R2,R3,R4,R5>	; SAVE REGISTERS
;
; COPY X AND CALCULATE X^2
;
	MOV	SP,R3		; POINT PAST WHERE X WILL BE BUILT
	FPUSH	14(SP)		; PUSH X
	MOV	SP,R5		; POINT PAST WHERE X^2 WILL BE BUILT
	FPUSH	-(R3)		; PUSH X
	FPUSH	-(R3)		; PUSH X
	JSR	R4,STAND
	.WORD 	$DMUL$
	.WORD	5$
;
; PICK UP POLYNOMIAL ORDERS AND CALCULATE X*P(X^2)
;
5$:	MOVB	(R0),R2		; ORDER OF P
	MOVB	1(R0),R3	; ORDER OF Q
	BR	1$
	.WORD	0,0,0,0
1$:	FPUSH	-(R0)		; PUSH P(N)

10$:	MOV	R5,R1		; COPY POINTER PAST X^2
	FPUSH	-(R1)		; X^2
	JSR	R4,STAND
	.WORD	$DMUL$
	.WORD	11$
11$:	FPUSH	-(R0)		; P(N-1) (ETC)
	JSR	R4,STAND
	.WORD	$DADD$
	.WORD	12$
12$:	DEC	R2		; DONE YET?
	BGT	10$		; NOPE
	TST	R3		; JUST A SINGLE POLYNOMIAL EVALUATION?
	BEQ	40$		; YES
	FPUSH	0(R5)		; X
	JSR	R4,STAND
	.WORD	$DMUL$
	.WORD	13$
;
; CALCULATE Q(X^2)
;
13$:	MOV	R5,R1		; POINT PAST X^2
	FPUSH	-(R1)		; X^2
20$:	FPUSH	-(R0)		; Q(N)
	JSR	R4,STAND
	.WORD	$DADD$
	.WORD	21$
21$:	DEC	R3		; DONE?
	BLE	30$		; YES
	MOV	R5,R1		; POINT PAST X^2
	FPUSH	-(R1)		; X^2
	JSR	R4,STAND
	.WORD	$DMUL$
	.WORD	20$
;
; CALCUALTE X*P(X^2)/Q(X^2), POP RESULT, RESTORE REGISTERS AND EXIT
;
30$:	JSR	R4,STAND	; 
	.WORD	$DDIV$
	.WORD	40$
40$:	FPOP	42(SP)		; STORE RESULT
	ADD	#20,SP		; KILL JUNK
	POP	<R5,R4,R3,R2,R1>	; RESTORE REGS
	TST	(SP)+
	JMP	@(R4)+
.SBTTL	SUPPORT ENTRY $B85,	DOUBLE FLOATING COMPARE
;
; THIS ROUTINE COMPARES THE TWO DOUBLE PRECISION REAL NUMBERS ON THE
; STACK AND RETURNS THE RESULT OF THE COMPARISON IN THE CONDITION
; CODES.
;
DCMP::
$B85:				; DOUBLE PRECISION COMPARE
	CMP	10(SP),@SP	; COMPARE FIRST WORDS
	BLO	10$
	BHI	20$
	CMP	12(SP),2(SP)	; COMPARE SECOND WORDS
	BLO	10$
	BHI	20$
	CMP	14(SP),4(SP)	; THIRD WORDS
	BLO	10$
	BHI	20$
	CMP	16(SP),6(SP)	; FOURTH WORDS
	BLO	10$
	BHI	20$
;
; VALUES ARE EQUAL
;
	CLR	10(SP)		;RETURN EQUAL COMPARISION
	BR	20$
;
; FIRST ARG LOWER THAN SECOND ARG.  RESULT IS NEGATED SECOND ARG
;
10$:
	NEG	@SP			;NEGATE SIGN OF SECOND ARG.
	MOV	@SP,10(SP)		;MOV THAT WORD TO FIRST ARG.
;
; FIRST ARG HIGHER THAN SECOND ARG.  RESULT IS FIRST ARG
;
20$:
	MOV	10(SP),16(SP)	;MOV FIRST WORD OF FIRST ARG. BEFORE RETURN
	ADD	#16,SP		;WIPE OUT JUNK ON STACK
	MOV	(SP)+,R0	;SET CONDITION CODES
	JMP	@(R4)+		;RETURN WITH COPARISION IN CONDITION CODES
.SBTTL	POWER
;
; THIS ROUTINE RISE REAL NUMBER TO INTEGER POWER
;
POW::	MOV	@SP,-(SP)
	BGE	1$
	NEG	@SP
	TST	4(SP)
	BNE	1$
	TRAP	11.
1$:	MOV	R4,-(SP)
	MOV	R4,SAVJMP
	ASR	2(SP)
	BCC	13$
	FPUSH	6(SP)
	TST	12(SP)
	BEQ	POW18
	BR	POW14
13$:	CLR	-(SP)
	CLR	-(SP)
	CLR	-(SP)
	MOV	#40200,-(SP)
	TST	12(SP)
	BEQ	POW18
POW14:	FPUSH	16(SP)
POW16:	FPUSH	0(SP)
	JSR	R4,STAND
	.WORD	$DMUL$
	.WORD	POW15
POW15:	ASR	22(SP)
	BCC	POW16
	FPUSH	10(SP)
	FPUSH	10(SP)
	JSR	R4,STAND
	.WORD	$DMUL$
	.WORD	17$
17$:	FPOP	16(SP)
	TST	22(SP)
	BNE	POW16
	ADD	#10,SP
POW18:	TST	14(SP)
	BGE	19$
	MOV	SP,R0
	FPUSH	0(SP)
	MOV	#40200,(0)+
	CLR	(0)+
	CLR	(0)+
	CLR	(0)+
	TST	@SP
	BNE	2$
	TRAP	6
2$:	JSR	R4,STAND
	.WORD	$DDIV$
	.WORD	19$
19$:	FPOP	14(SP)
	MOV	(SP)+,R4
	CMP	(SP)+,(SP)+
	CLR	SAVJMP
	JMP	@(4)+
;
	.END
